import { DOCUMENT, CommonModule } from '@angular/common';
import { isDevMode, SecurityContext, Injectable, RendererFactory2, Optional, Inject, Directive, ElementRef, Renderer2, Input, NgModule } from '@angular/core';
import { generate } from '@ant-design/colors';
import { HttpClient, HttpBackend } from '@angular/common/http';
import { DomSanitizer } from '@angular/platform-browser';
import { Subject, of, Observable } from 'rxjs';
import { map, tap, finalize, catchError, share, filter, take } from 'rxjs/operators';

const ANT_ICON_ANGULAR_CONSOLE_PREFIX = '[@ant-design/icons-angular]:';
function error(message) {
    console.error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
}
function warn(message) {
    if (isDevMode()) {
        console.warn(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
    }
}
function getSecondaryColor(primaryColor) {
    return generate(primaryColor)[0];
}
function withSuffix(name, theme) {
    switch (theme) {
        case 'fill': return `${name}-fill`;
        case 'outline': return `${name}-o`;
        case 'twotone': return `${name}-twotone`;
        case undefined: return name;
        default: throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Theme "${theme}" is not a recognized theme!`);
    }
}
function withSuffixAndColor(name, theme, pri, sec) {
    return `${withSuffix(name, theme)}-${pri}-${sec}`;
}
function mapAbbrToTheme(abbr) {
    return abbr === 'o' ? 'outline' : abbr;
}
function alreadyHasAThemeSuffix(name) {
    return name.endsWith('-fill') || name.endsWith('-o') || name.endsWith('-twotone');
}
function isIconDefinition(target) {
    return (typeof target === 'object' &&
        typeof target.name === 'string' &&
        (typeof target.theme === 'string' || target.theme === undefined) &&
        typeof target.icon === 'string');
}
/**
 * Get an `IconDefinition` object from abbreviation type, like `account-book-fill`.
 * @param str
 */
function getIconDefinitionFromAbbr(str) {
    const arr = str.split('-');
    const theme = mapAbbrToTheme(arr.splice(arr.length - 1, 1)[0]);
    const name = arr.join('-');
    return {
        name,
        theme,
        icon: ''
    };
}
function cloneSVG(svg) {
    return svg.cloneNode(true);
}
/**
 * Parse inline SVG string and replace colors with placeholders. For twotone icons only.
 */
function replaceFillColor(raw) {
    return raw
        .replace(/['"]#333['"]/g, '"primaryColor"')
        .replace(/['"]#E6E6E6['"]/g, '"secondaryColor"')
        .replace(/['"]#D9D9D9['"]/g, '"secondaryColor"')
        .replace(/['"]#D8D8D8['"]/g, '"secondaryColor"');
}
/**
 * Split a name with namespace in it into a tuple like [ name, namespace ].
 */
function getNameAndNamespace(type) {
    const split = type.split(':');
    switch (split.length) {
        case 1: return [type, ''];
        case 2: return [split[1], split[0]];
        default: throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The icon type ${type} is not valid!`);
    }
}
function hasNamespace(type) {
    return getNameAndNamespace(type)[1] !== '';
}

function NameSpaceIsNotSpecifyError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Type should have a namespace. Try "namespace:${name}".`);
}
function IconNotFoundError(icon) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}the icon ${icon} does not exist or is not registered.`);
}
function HttpModuleNotImport() {
    error(`you need to import "HttpClientModule" to use dynamic importing.`);
    return null;
}
function UrlNotSafeError(url) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The url "${url}" is unsafe.`);
}
function SVGTagNotFoundError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}<svg> tag not found.`);
}
function DynamicLoadingTimeoutError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Importing timeout error.`);
}

const JSONP_HANDLER_NAME = '__ant_icon_load';
class IconService {
    constructor(_rendererFactory, _handler, 
    // tslint:disable-next-line:no-any
    _document, sanitizer) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.sanitizer = sanitizer;
        this.defaultTheme = 'outline';
        /**
         * All icon definitions would be registered here.
         */
        this._svgDefinitions = new Map();
        /**
         * Cache all rendered icons. Icons are identified by name, theme,
         * and for twotone icons, primary color and secondary color.
         */
        this._svgRenderedDefinitions = new Map();
        this._inProgressFetches = new Map();
        /**
         * Url prefix for fetching inline SVG by dynamic importing.
         */
        this._assetsUrlRoot = '';
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        /** A flag indicates whether jsonp loading is enabled. */
        this._enableJsonpLoading = false;
        this._jsonpIconLoad$ = new Subject();
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    set twoToneColor({ primaryColor, secondaryColor }) {
        this._twoToneColorPalette.primaryColor = primaryColor;
        this._twoToneColorPalette.secondaryColor =
            secondaryColor || getSecondaryColor(primaryColor);
    }
    get twoToneColor() {
        // Make a copy to avoid unexpected changes.
        return Object.assign({}, this._twoToneColorPalette);
    }
    /**
     * Call this method to switch to jsonp like loading.
     */
    useJsonpLoading() {
        if (!this._enableJsonpLoading) {
            this._enableJsonpLoading = true;
            window[JSONP_HANDLER_NAME] = (icon) => {
                this._jsonpIconLoad$.next(icon);
            };
        }
        else {
            warn('You are already using jsonp loading.');
        }
    }
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param prefix
     */
    changeAssetsSource(prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Add icons provided by ant design.
     * @param icons
     */
    addIcon(...icons) {
        icons.forEach(icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    }
    /**
     * Register an icon. Namespace is required.
     * @param type
     * @param literal
     */
    addIconLiteral(type, literal) {
        const [_, namespace] = getNameAndNamespace(type);
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    }
    /**
     * Remove all cache.
     */
    clear() {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    }
    /**
     * Get a rendered `SVGElement`.
     * @param icon
     * @param twoToneColor
     */
    getRenderedContent(icon, twoToneColor) {
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        const definitionOrNull = isIconDefinition(icon)
            ? icon
            : this._svgDefinitions.get(icon) || null;
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`.
        // Otherwise try to fetch it from remote.
        const $iconDefinition = definitionOrNull
            ? of(definitionOrNull)
            : this._loadIconDynamically(icon);
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map(i => {
            if (!i) {
                throw IconNotFoundError(icon);
            }
            return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        }));
    }
    getCachedIcons() {
        return this._svgDefinitions;
    }
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @param type
     */
    _loadIconDynamically(type) {
        // If developer doesn't provide HTTP module nor enable jsonp loading, just throw an error.
        if (!this._http && !this._enableJsonpLoading) {
            return of(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time,
        // request should only be fired once.
        let inProgress = this._inProgressFetches.get(type);
        if (!inProgress) {
            const [name, namespace] = getNameAndNamespace(type);
            // If the string has a namespace within, create a simple `IconDefinition`.
            const icon = namespace
                ? { name: type, icon: '' }
                : getIconDefinitionFromAbbr(name);
            const suffix = this._enableJsonpLoading ? '.js' : '.svg';
            const url = (namespace
                ? `${this._assetsUrlRoot}assets/${namespace}/${name}`
                : `${this._assetsUrlRoot}assets/${icon.theme}/${icon.name}`) + suffix;
            const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            const source = !this._enableJsonpLoading
                ? this._http
                    .get(safeUrl, { responseType: 'text' })
                    .pipe(map(literal => (Object.assign(Object.assign({}, icon), { icon: literal }))))
                : this._loadIconDynamicallyWithJsonp(icon, safeUrl);
            inProgress = source.pipe(tap(definition => this.addIcon(definition)), finalize(() => this._inProgressFetches.delete(type)), catchError(() => of(null)), share());
            this._inProgressFetches.set(type, inProgress);
        }
        return inProgress;
    }
    _loadIconDynamicallyWithJsonp(icon, url) {
        return new Observable(subscriber => {
            const loader = this._document.createElement('script');
            const timer = setTimeout(() => {
                clean();
                subscriber.error(DynamicLoadingTimeoutError());
            }, 6000);
            loader.src = url;
            function clean() {
                loader.parentNode.removeChild(loader);
                clearTimeout(timer);
            }
            this._document.body.appendChild(loader);
            this._jsonpIconLoad$
                .pipe(filter(i => i.name === icon.name && i.theme === icon.theme), take(1))
                .subscribe(i => {
                subscriber.next(i);
                clean();
            });
        });
    }
    /**
     * Render a new `SVGElement` for a given `IconDefinition`, or make a copy from cache.
     * @param icon
     * @param twoToneColor
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        let svg;
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        const key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined
                ? icon.name
                : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        const cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, Object.assign(Object.assign({}, icon), { icon: svg }));
        }
        return cloneSVG(svg);
    }
    _createSVGElementFromString(str) {
        const div = this._document.createElement('div');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    }
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            const children = svg.childNodes;
            const length = children.length;
            for (let i = 0; i < length; i++) {
                const child = children[i];
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
}
IconService.decorators = [
    { type: Injectable }
];
IconService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: HttpBackend, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: DomSanitizer }
];

function checkMeta(prev, after) {
    return prev.type === after.type && prev.theme === after.theme && prev.twoToneColor === after.twoToneColor;
}
class IconDirective {
    constructor(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
            }
            else {
                const preMeta = this._getSelfRenderMeta();
                this._iconService.getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor).subscribe(svg => {
                    // avoid race condition, see https://github.com/ant-design/ant-design-icons/issues/315
                    if (checkMeta(preMeta, this._getSelfRenderMeta())) {
                        this._setSVGElement(svg);
                        resolve(svg);
                    }
                    else {
                        resolve(null);
                    }
                });
            }
        });
    }
    _getSelfRenderMeta() {
        return {
            type: this.type,
            theme: this.theme,
            twoToneColor: this.twoToneColor
        };
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (!!theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        var _a;
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            const child = children[i];
            if (((_a = child.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
}
IconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[antIcon]'
            },] }
];
IconDirective.ctorParameters = () => [
    { type: IconService },
    { type: ElementRef },
    { type: Renderer2 }
];
IconDirective.propDecorators = {
    type: [{ type: Input }],
    theme: [{ type: Input }],
    twoToneColor: [{ type: Input }]
};

class IconModule {
}
IconModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [IconDirective],
                declarations: [IconDirective],
                providers: [IconService]
            },] }
];

const manifest = {
    fill: [
        'account-book', 'alert', 'alipay-circle', 'alipay-square', 'amazon-circle', 'android', 'aliwangwang', 'amazon-square', 'api', 'appstore', 'apple', 'audio', 'backward', 'bank', 'bell', 'behance-circle', 'behance-square', 'book', 'box-plot', 'bug', 'bulb', 'build', 'calculator', 'calendar', 'camera', 'caret-left', 'car', 'caret-down', 'caret-right', 'carry-out', 'caret-up', 'check-circle', 'check-square', 'chrome', 'ci-circle', 'clock-circle', 'close-circle', 'close-square', 'cloud', 'code-sandbox-circle', 'code', 'code-sandbox-square', 'codepen-square', 'codepen-circle', 'container', 'contacts', 'control', 'copy', 'compass', 'credit-card', 'crown', 'copyright-circle', 'customer-service', 'dashboard', 'database', 'delete', 'diff', 'dollar-circle', 'dislike', 'dingtalk-square', 'dingtalk-circle', 'down-circle', 'down-square', 'dribbble-circle', 'dropbox-circle', 'dribbble-square', 'dropbox-square', 'environment', 'edit', 'euro-circle', 'exclamation-circle', 'experiment', 'eye', 'eye-invisible', 'facebook', 'fast-forward', 'file-add', 'fast-backward', 'file-excel', 'file-exclamation', 'file-image', 'file', 'file-text', 'file-ppt', 'file-word', 'file-unknown', 'file-zip', 'filter', 'file-pdf', 'file-markdown', 'folder-open', 'fire', 'flag', 'folder', 'forward', 'format-painter', 'frown', 'fund', 'folder-add', 'funnel-plot', 'gold', 'gitlab', 'gift', 'google-circle', 'google-plus-circle', 'github', 'google-square', 'golden', 'google-plus-square', 'heart', 'hdd', 'home', 'highlight', 'hourglass', 'html5', 'idcard', 'ie-circle', 'ie-square', 'info-circle', 'insurance', 'instagram', 'interaction', 'layout', 'left-circle', 'left-square', 'like', 'linkedin', 'lock', 'mail', 'mac-command', 'medicine-box', 'medium-circle', 'meh', 'medium-square', 'minus-circle', 'message', 'money-collect', 'notification', 'pause-circle', 'pay-circle', 'minus-square', 'mobile', 'picture', 'phone', 'pie-chart', 'play-square', 'play-circle', 'plus-circle', 'plus-square', 'pound-circle', 'printer', 'project', 'property-safety', 'pushpin', 'qq-circle', 'qq-square', 'question-circle', 'read', 'profile', 'reconciliation', 'reddit-circle', 'red-envelope', 'reddit-square', 'rest', 'right-square', 'right-circle', 'robot', 'rocket', 'save', 'schedule', 'security-scan', 'setting', 'shop', 'shopping', 'safety-certificate', 'signal', 'sketch-square', 'skype', 'skin', 'slack-circle', 'slack-square', 'sliders', 'snippets', 'sound', 'smile', 'sketch-circle', 'step-forward', 'star', 'step-backward', 'stop', 'switcher', 'tablet', 'tags', 'tag', 'taobao-square', 'taobao-circle', 'tool', 'thunderbolt', 'trademark-circle', 'trophy', 'twitter-circle', 'twitter-square', 'unlock', 'up-circle', 'usb', 'up-square', 'video-camera', 'wallet', 'warning', 'weibo-circle', 'weibo-square', 'wechat', 'youtube', 'windows', 'zhihu-circle', 'yuque', 'zhihu-square', 'yahoo'
    ],
    outline: [
        'account-book', 'alibaba', 'aim', 'alert', 'align-center', 'alipay-circle', 'alipay', 'align-left', 'align-right', 'amazon', 'aliwangwang', 'aliyun', 'ant-cloud', 'android', 'apartment', 'api', 'ant-design', 'appstore-add', 'apple', 'appstore', 'arrow-down', 'arrows-alt', 'arrow-up', 'area-chart', 'arrow-left', 'arrow-right', 'audit', 'audio-muted', 'audio', 'backward', 'barcode', 'bars', 'bank', 'bold', 'bell', 'behance', 'block', 'behance-square', 'bg-colors', 'bar-chart', 'border-outer', 'border-left', 'border-bottom', 'border-horizontal', 'border-top', 'border', 'border-inner', 'border-right', 'box-plot', 'book', 'borderless-table', 'border-verticle', 'build', 'bug', 'bulb', 'calendar', 'calculator', 'camera', 'caret-down', 'car', 'caret-right', 'caret-up', 'carry-out', 'caret-left', 'branches', 'check-circle', 'check-square', 'check', 'ci', 'chrome', 'clock-circle', 'ci-circle', 'clear', 'close-circle', 'close', 'close-square', 'cloud-download', 'cloud-server', 'cloud-upload', 'cloud-sync', 'cluster', 'codepen-circle', 'cloud', 'code-sandbox', 'code', 'codepen', 'coffee', 'column-width', 'compress', 'column-height', 'comment', 'compass', 'console-sql', 'contacts', 'container', 'copy', 'copyright', 'copyright-circle', 'control', 'crown', 'credit-card', 'customer-service', 'dash', 'database', 'dashboard', 'delete-row', 'delete-column', 'delivered-procedure', 'delete', 'desktop', 'diff', 'deployment-unit', 'dingtalk', 'disconnect', 'dollar', 'dislike', 'dollar-circle', 'double-left', 'down', 'down-square', 'double-right', 'down-circle', 'download', 'dot-chart', 'dribbble', 'dribbble-square', 'dingding', 'edit', 'ellipsis', 'enter', 'euro-circle', 'euro', 'expand-alt', 'environment', 'experiment', 'expand', 'exception', 'export', 'exclamation-circle', 'exclamation', 'dropbox', 'drag', 'facebook', 'eye', 'field-binary', 'field-number', 'fast-backward', 'fast-forward', 'field-string', 'file-done', 'file-add', 'file-exclamation', 'field-time', 'file-excel', 'file-gif', 'file-markdown', 'fall', 'file-image', 'eye-invisible', 'file-pdf', 'file-search', 'file-jpg', 'file-ppt', 'file-sync', 'file-unknown', 'file-protect', 'file-text', 'file-word', 'fire', 'file-zip', 'filter', 'file', 'flag', 'folder', 'folder-view', 'font-colors', 'forward', 'folder-open', 'fork', 'format-painter', 'form', 'fullscreen', 'font-size', 'function', 'fund-view', 'fullscreen-exit', 'gif', 'fund-projection-screen', 'gift', 'fund', 'frown', 'github', 'folder-add', 'gitlab', 'gold', 'google', 'google-plus', 'global', 'heart', 'group', 'heat-map', 'gateway', 'funnel-plot', 'home', 'history', 'highlight', 'hdd', 'html5', 'hourglass', 'idcard', 'ie', 'inbox', 'import', 'info-circle', 'insert-row-above', 'insert-row-right', 'info', 'insert-row-below', 'insert-row-left', 'instagram', 'interaction', 'italic', 'layout', 'issues-close', 'laptop', 'key', 'left', 'left-circle', 'left-square', 'line', 'linkedin', 'line-chart', 'line-height', 'link', 'like', 'insurance', 'loading-3-quarters', 'mac-command', 'loading', 'mail', 'login', 'medicine-box', 'man', 'medium', 'medium-workmark', 'menu-fold', 'meh', 'merge-cells', 'menu', 'menu-unfold', 'lock', 'minus', 'minus-circle', 'logout', 'message', 'minus-square', 'mobile', 'money-collect', 'more', 'notification', 'node-index', 'node-expand', 'monitor', 'ordered-list', 'node-collapse', 'number', 'paper-clip', 'partition', 'pause', 'one-to-one', 'pay-circle', 'pause-circle', 'pic-center', 'pic-right', 'percentage', 'picture', 'pie-chart', 'play-square', 'play-circle', 'plus-circle', 'plus-square', 'plus', 'pound', 'pound-circle', 'poweroff', 'phone', 'pic-left', 'printer', 'profile', 'project', 'pull-request', 'property-safety', 'pushpin', 'qq', 'qrcode', 'radar-chart', 'radius-upright', 'question-circle', 'question', 'radius-upleft', 'radius-bottomleft', 'radius-setting', 'radius-bottomright', 'read', 'reload', 'reconciliation', 'redo', 'reddit', 'right-circle', 'rest', 'right', 'right-square', 'retweet', 'rise', 'rocket', 'robot', 'red-envelope', 'rollback', 'rotate-right', 'rotate-left', 'save', 'safety', 'safety-certificate', 'scan', 'search', 'schedule', 'security-scan', 'scissor', 'select', 'send', 'setting', 'share-alt', 'shop', 'shrink', 'shake', 'shopping', 'shopping-cart', 'sisternode', 'skin', 'sketch', 'skype', 'slack-square', 'small-dash', 'sliders', 'snippets', 'smile', 'solution', 'slack', 'sort-ascending', 'sort-descending', 'sound', 'split-cells', 'star', 'stock', 'step-forward', 'subnode', 'swap-left', 'stop', 'swap-right', 'swap', 'switcher', 'sync', 'strikethrough', 'tag', 'tablet', 'table', 'taobao-circle', 'step-backward', 'tags', 'taobao', 'thunderbolt', 'team', 'to-top', 'tool', 'transaction', 'trademark-circle', 'translation', 'trophy', 'trademark', 'twitter', 'underline', 'undo', 'ungroup', 'unlock', 'up', 'up-circle', 'unordered-list', 'up-square', 'user-add', 'usergroup-delete', 'user', 'usb', 'user-delete', 'user-switch', 'vertical-left', 'vertical-align-bottom', 'verified', 'usergroup-add', 'upload', 'vertical-align-middle', 'vertical-align-top', 'vertical-right', 'video-camera', 'video-camera-add', 'wallet', 'warning', 'wechat', 'weibo', 'weibo-square', 'weibo-circle', 'whats-app', 'wifi', 'woman', 'yahoo', 'windows', 'youtube', 'yuque', 'zhihu', 'zoom-in', 'zoom-out'
    ],
    twotone: [
        'account-book', 'alert', 'api', 'appstore', 'audio', 'bank', 'bell', 'book', 'box-plot', 'build', 'bug', 'bulb', 'calculator', 'calendar', 'camera', 'car', 'carry-out', 'check-circle', 'ci-circle', 'check-square', 'ci', 'close-circle', 'clock-circle', 'close-square', 'cloud', 'code', 'compass', 'container', 'contacts', 'copy', 'control', 'copyright', 'customer-service', 'dashboard', 'crown', 'credit-card', 'database', 'delete', 'copyright-circle', 'diff', 'dollar-circle', 'dislike', 'dollar', 'down-square', 'down-circle', 'euro', 'edit', 'environment', 'euro-circle', 'exclamation-circle', 'experiment', 'eye-invisible', 'eye', 'file-add', 'file-excel', 'file-image', 'file-exclamation', 'file-markdown', 'file-ppt', 'file-pdf', 'file-text', 'file-unknown', 'file-word', 'filter', 'fire', 'flag', 'file', 'file-zip', 'folder-add', 'folder', 'folder-open', 'frown', 'fund', 'funnel-plot', 'gold', 'gift', 'hdd', 'heart', 'home', 'hourglass', 'html5', 'idcard', 'info-circle', 'highlight', 'interaction', 'layout', 'left-circle', 'left-square', 'like', 'insurance', 'lock', 'mail', 'medicine-box', 'message', 'meh', 'minus-circle', 'minus-square', 'mobile', 'money-collect', 'notification', 'pause-circle', 'phone', 'picture', 'play-circle', 'play-square', 'pie-chart', 'plus-square', 'plus-circle', 'pound-circle', 'project', 'profile', 'pushpin', 'property-safety', 'question-circle', 'printer', 'red-envelope', 'rest', 'right-circle', 'right-square', 'rocket', 'reconciliation', 'safety-certificate', 'save', 'schedule', 'security-scan', 'setting', 'shop', 'shopping', 'skin', 'sliders', 'smile', 'snippets', 'sound', 'star', 'stop', 'switcher', 'tablet', 'tags', 'tag', 'thunderbolt', 'tool', 'trademark-circle', 'trophy', 'unlock', 'up-circle', 'usb', 'up-square', 'video-camera', 'wallet', 'warning'
    ]
};

/**
 * Generated bundle index. Do not edit.
 */

export { ANT_ICON_ANGULAR_CONSOLE_PREFIX, DynamicLoadingTimeoutError, HttpModuleNotImport, IconDirective, IconModule, IconNotFoundError, IconService, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError, alreadyHasAThemeSuffix, cloneSVG, error, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, manifest, mapAbbrToTheme, replaceFillColor, warn, withSuffix, withSuffixAndColor };
//# sourceMappingURL=ant-design-icons-angular.js.map
