/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
export class NzTreeIndentComponent {
    constructor() {
        this.nzTreeLevel = 0;
        this.nzIsStart = [];
        this.nzIsEnd = [];
        this.nzSelectMode = false;
        this.listOfUnit = [];
    }
    ngOnChanges(changes) {
        const { nzTreeLevel } = changes;
        if (nzTreeLevel) {
            this.listOfUnit = [...new Array(nzTreeLevel.currentValue || 0)];
        }
    }
}
NzTreeIndentComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tree-indent',
                exportAs: 'nzTreeIndent',
                template: `
    <span
      [class.ant-tree-indent-unit]="!nzSelectMode"
      [class.ant-select-tree-indent-unit]="nzSelectMode"
      [class.ant-select-tree-indent-unit-start]="nzSelectMode && nzIsStart[i]"
      [class.ant-tree-indent-unit-start]="!nzSelectMode && nzIsStart[i]"
      [class.ant-select-tree-indent-unit-end]="nzSelectMode && nzIsEnd[i]"
      [class.ant-tree-indent-unit-end]="!nzSelectMode && nzIsEnd[i]"
      *ngFor="let _ of listOfUnit; let i = index"
    ></span>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                host: {
                    '[attr.aria-hidden]': 'true',
                    '[class.ant-tree-indent]': '!nzSelectMode',
                    '[class.ant-select-tree-indent]': 'nzSelectMode'
                }
            },] }
];
NzTreeIndentComponent.propDecorators = {
    nzTreeLevel: [{ type: Input }],
    nzIsStart: [{ type: Input }],
    nzIsEnd: [{ type: Input }],
    nzSelectMode: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1pbmRlbnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlL3RyZWUtaW5kZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBNEIsTUFBTSxlQUFlLENBQUM7QUF3QnBHLE1BQU0sT0FBTyxxQkFBcUI7SUF0QmxDO1FBdUJXLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLGNBQVMsR0FBYyxFQUFFLENBQUM7UUFDMUIsWUFBTyxHQUFjLEVBQUUsQ0FBQztRQUN4QixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQUU5QixlQUFVLEdBQWEsRUFBRSxDQUFDO0lBUTVCLENBQUM7SUFOQyxXQUFXLENBQUMsT0FBc0I7UUFDaEMsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUNoQyxJQUFJLFdBQVcsRUFBRTtZQUNmLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRTtJQUNILENBQUM7OztZQW5DRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFFBQVEsRUFBRTs7Ozs7Ozs7OztHQVVUO2dCQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO2dCQUMxQixJQUFJLEVBQUU7b0JBQ0osb0JBQW9CLEVBQUUsTUFBTTtvQkFDNUIseUJBQXlCLEVBQUUsZUFBZTtvQkFDMUMsZ0NBQWdDLEVBQUUsY0FBYztpQkFDakQ7YUFDRjs7OzBCQUVFLEtBQUs7d0JBQ0wsS0FBSztzQkFDTCxLQUFLOzJCQUNMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ256LXRyZWUtaW5kZW50JyxcbiAgZXhwb3J0QXM6ICduelRyZWVJbmRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuXG4gICAgICBbY2xhc3MuYW50LXRyZWUtaW5kZW50LXVuaXRdPVwiIW56U2VsZWN0TW9kZVwiXG4gICAgICBbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudC11bml0XT1cIm56U2VsZWN0TW9kZVwiXG4gICAgICBbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudC11bml0LXN0YXJ0XT1cIm56U2VsZWN0TW9kZSAmJiBueklzU3RhcnRbaV1cIlxuICAgICAgW2NsYXNzLmFudC10cmVlLWluZGVudC11bml0LXN0YXJ0XT1cIiFuelNlbGVjdE1vZGUgJiYgbnpJc1N0YXJ0W2ldXCJcbiAgICAgIFtjbGFzcy5hbnQtc2VsZWN0LXRyZWUtaW5kZW50LXVuaXQtZW5kXT1cIm56U2VsZWN0TW9kZSAmJiBueklzRW5kW2ldXCJcbiAgICAgIFtjbGFzcy5hbnQtdHJlZS1pbmRlbnQtdW5pdC1lbmRdPVwiIW56U2VsZWN0TW9kZSAmJiBueklzRW5kW2ldXCJcbiAgICAgICpuZ0Zvcj1cImxldCBfIG9mIGxpc3RPZlVuaXQ7IGxldCBpID0gaW5kZXhcIlxuICAgID48L3NwYW4+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5hbnQtdHJlZS1pbmRlbnRdJzogJyFuelNlbGVjdE1vZGUnLFxuICAgICdbY2xhc3MuYW50LXNlbGVjdC10cmVlLWluZGVudF0nOiAnbnpTZWxlY3RNb2RlJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZUluZGVudENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG56VHJlZUxldmVsID0gMDtcbiAgQElucHV0KCkgbnpJc1N0YXJ0OiBib29sZWFuW10gPSBbXTtcbiAgQElucHV0KCkgbnpJc0VuZDogYm9vbGVhbltdID0gW107XG4gIEBJbnB1dCgpIG56U2VsZWN0TW9kZSA9IGZhbHNlO1xuXG4gIGxpc3RPZlVuaXQ6IG51bWJlcltdID0gW107XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGNvbnN0IHsgbnpUcmVlTGV2ZWwgfSA9IGNoYW5nZXM7XG4gICAgaWYgKG56VHJlZUxldmVsKSB7XG4gICAgICB0aGlzLmxpc3RPZlVuaXQgPSBbLi4ubmV3IEFycmF5KG56VHJlZUxldmVsLmN1cnJlbnRWYWx1ZSB8fCAwKV07XG4gICAgfVxuICB9XG59XG4iXX0=