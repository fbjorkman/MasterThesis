{"ast":null,"code":"import { CommonModule } from '@angular/common';\nimport { TemplateRef, Directive, ViewContainerRef, Input, NgModule } from '@angular/core';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet NzStringTemplateOutletDirective = /*#__PURE__*/(() => {\n  class NzStringTemplateOutletDirective {\n    constructor(viewContainer, templateRef) {\n      this.viewContainer = viewContainer;\n      this.templateRef = templateRef;\n      this.embeddedViewRef = null;\n      this.context = new NzStringTemplateOutletContext();\n      this.nzStringTemplateOutletContext = null;\n      this.nzStringTemplateOutlet = null;\n    }\n\n    static ngTemplateContextGuard(_dir, _ctx) {\n      return true;\n    }\n\n    recreateView() {\n      this.viewContainer.clear();\n      const isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\n      const templateRef = isTemplateRef ? this.nzStringTemplateOutlet : this.templateRef;\n      this.embeddedViewRef = this.viewContainer.createEmbeddedView(templateRef, isTemplateRef ? this.nzStringTemplateOutletContext : this.context);\n    }\n\n    updateContext() {\n      const isTemplateRef = this.nzStringTemplateOutlet instanceof TemplateRef;\n      const newCtx = isTemplateRef ? this.nzStringTemplateOutletContext : this.context;\n      const oldCtx = this.embeddedViewRef.context;\n\n      if (newCtx) {\n        for (const propName of Object.keys(newCtx)) {\n          oldCtx[propName] = newCtx[propName];\n        }\n      }\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzStringTemplateOutletContext,\n        nzStringTemplateOutlet\n      } = changes;\n\n      const shouldRecreateView = () => {\n        let shouldOutletRecreate = false;\n\n        if (nzStringTemplateOutlet) {\n          if (nzStringTemplateOutlet.firstChange) {\n            shouldOutletRecreate = true;\n          } else {\n            const isPreviousOutletTemplate = nzStringTemplateOutlet.previousValue instanceof TemplateRef;\n            const isCurrentOutletTemplate = nzStringTemplateOutlet.currentValue instanceof TemplateRef;\n            shouldOutletRecreate = isPreviousOutletTemplate || isCurrentOutletTemplate;\n          }\n        }\n\n        const hasContextShapeChanged = ctxChange => {\n          const prevCtxKeys = Object.keys(ctxChange.previousValue || {});\n          const currCtxKeys = Object.keys(ctxChange.currentValue || {});\n\n          if (prevCtxKeys.length === currCtxKeys.length) {\n            for (const propName of currCtxKeys) {\n              if (prevCtxKeys.indexOf(propName) === -1) {\n                return true;\n              }\n            }\n\n            return false;\n          } else {\n            return true;\n          }\n        };\n\n        const shouldContextRecreate = nzStringTemplateOutletContext && hasContextShapeChanged(nzStringTemplateOutletContext);\n        return shouldContextRecreate || shouldOutletRecreate;\n      };\n\n      if (nzStringTemplateOutlet) {\n        this.context.$implicit = nzStringTemplateOutlet.currentValue;\n      }\n\n      const recreateView = shouldRecreateView();\n\n      if (recreateView) {\n        /** recreate view when context shape or outlet change **/\n        this.recreateView();\n      } else {\n        /** update context **/\n        this.updateContext();\n      }\n    }\n\n  }\n\n  NzStringTemplateOutletDirective.ɵfac = function NzStringTemplateOutletDirective_Factory(t) {\n    return new (t || NzStringTemplateOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  NzStringTemplateOutletDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzStringTemplateOutletDirective,\n    selectors: [[\"\", \"nzStringTemplateOutlet\", \"\"]],\n    inputs: {\n      nzStringTemplateOutletContext: \"nzStringTemplateOutletContext\",\n      nzStringTemplateOutlet: \"nzStringTemplateOutlet\"\n    },\n    exportAs: [\"nzStringTemplateOutlet\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return NzStringTemplateOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass NzStringTemplateOutletContext {}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzOutletModule = /*#__PURE__*/(() => {\n  class NzOutletModule {}\n\n  NzOutletModule.ɵfac = function NzOutletModule_Factory(t) {\n    return new (t || NzOutletModule)();\n  };\n\n  NzOutletModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NzOutletModule\n  });\n  NzOutletModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NzOutletModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzOutletModule, {\n    declarations: function () {\n      return [NzStringTemplateOutletDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [NzStringTemplateOutletDirective];\n    }\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzOutletModule, NzStringTemplateOutletDirective }; //# sourceMappingURL=ng-zorro-antd-core-outlet.js.map","map":null,"metadata":{},"sourceType":"module"}