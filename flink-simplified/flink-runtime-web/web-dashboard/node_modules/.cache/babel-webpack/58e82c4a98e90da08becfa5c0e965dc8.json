{"ast":null,"code":"import * as G2 from '@antv/g2';\nimport { Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, takeUntil } from 'rxjs/operators';\nimport { COLOR_MAP } from 'config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"services\";\nimport * as i2 from \"ng-zorro-antd/divider\";\nimport * as i3 from \"@angular/common\";\nconst _c0 = [\"mainTimeLine\"];\nconst _c1 = [\"subTaskTimeLine\"];\n\nfunction JobTimelineComponent_nz_divider_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"nz-divider\", 6);\n  }\n} /// <reference path=\"../../../../../node_modules/@antv/g2/src/index.d.ts\" />\n\n\nexport let JobTimelineComponent = /*#__PURE__*/(() => {\n  class JobTimelineComponent {\n    constructor(jobService, cdr) {\n      this.jobService = jobService;\n      this.cdr = cdr;\n      this.destroy$ = new Subject();\n      this.listOfVertex = [];\n      this.listOfSubTaskTimeLine = [];\n      this.isShowSubTaskTimeLine = false;\n    }\n\n    updateSubTaskChart(vertexId) {\n      this.listOfSubTaskTimeLine = [];\n      this.jobService.loadSubTaskTimes(this.jobDetail.jid, vertexId).subscribe(data => {\n        data.subtasks.forEach(task => {\n          const listOfTimeLine = [];\n\n          for (const key in task.timestamps) {\n            // @ts-ignore\n            const time = task.timestamps[key];\n\n            if (time > 0) {\n              listOfTimeLine.push({\n                status: key,\n                startTime: time\n              });\n            }\n          }\n\n          listOfTimeLine.sort((pre, next) => pre.startTime - next.startTime);\n          listOfTimeLine.forEach((item, index) => {\n            if (index === listOfTimeLine.length - 1) {\n              this.listOfSubTaskTimeLine.push({\n                name: `${task.subtask} - ${task.host}`,\n                status: item.status,\n                range: [item.startTime, task.duration + listOfTimeLine[0].startTime]\n              });\n            } else {\n              this.listOfSubTaskTimeLine.push({\n                name: `${task.subtask} - ${task.host}`,\n                status: item.status,\n                range: [item.startTime, listOfTimeLine[index + 1].startTime]\n              });\n            }\n          });\n        });\n        this.subTaskChartInstance.changeHeight(Math.max(data.subtasks.length * 50 + 100, 150));\n        this.subTaskChartInstance.source(this.listOfSubTaskTimeLine, {\n          range: {\n            alias: 'Time',\n            type: 'time',\n            mask: 'HH:mm:ss',\n            nice: false\n          }\n        });\n        this.subTaskChartInstance.render();\n        this.isShowSubTaskTimeLine = true;\n        this.cdr.markForCheck();\n        setTimeout(() => {\n          try {\n            document.getElementById('subtask').scrollIntoViewIfNeeded();\n          } catch (e) {}\n        });\n      });\n    }\n\n    setUpMainChart() {\n      this.mainChartInstance = new G2.Chart({\n        container: this.mainTimeLine.nativeElement,\n        forceFit: true,\n        animate: false,\n        height: 500,\n        padding: [50, 50, 50, 50]\n      });\n      this.mainChartInstance.axis('id', false);\n      this.mainChartInstance.coord('rect').transpose().scale(1, -1);\n      this.mainChartInstance.interval().position('id*range') // @ts-ignore\n      .color('status', type => COLOR_MAP[type]).label('name', {\n        offset: -20,\n        formatter: text => {\n          if (text.length <= 120) {\n            return text;\n          } else {\n            return text.slice(0, 120) + '...';\n          }\n        },\n        textStyle: {\n          fill: '#ffffff',\n          textAlign: 'right',\n          fontWeight: 'bold'\n        }\n      });\n      this.mainChartInstance.tooltip({\n        title: 'name'\n      });\n      this.mainChartInstance.on('click', e => {\n        if (this.mainChartInstance.getSnapRecords(e).length) {\n          const data = this.mainChartInstance.getSnapRecords(e)[0]._origin;\n\n          this.selectedName = data.name;\n          this.updateSubTaskChart(data.id);\n        }\n      });\n    }\n\n    setUpSubTaskChart() {\n      this.subTaskChartInstance = new G2.Chart({\n        container: this.subTaskTimeLine.nativeElement,\n        forceFit: true,\n        height: 10,\n        animate: false,\n        padding: [50, 50, 50, 300]\n      });\n      this.subTaskChartInstance.coord('rect').transpose().scale(1, -1);\n      this.subTaskChartInstance.interval().position('name*range') // @ts-ignore\n      .color('status', type => COLOR_MAP[type]);\n    }\n\n    ngAfterViewInit() {\n      this.setUpMainChart();\n      this.setUpSubTaskChart();\n      this.jobService.jobDetail$.pipe(filter(() => !!this.mainChartInstance), distinctUntilChanged((pre, next) => pre.jid === next.jid), takeUntil(this.destroy$)).subscribe(data => {\n        this.jobDetail = data;\n        this.listOfVertex = data.vertices.filter(v => v['start-time'] > -1).map(vertex => {\n          const endTime = vertex['end-time'] > -1 ? vertex['end-time'] : vertex['start-time'] + vertex.duration;\n          return Object.assign(Object.assign({}, vertex), {\n            range: [vertex['start-time'], endTime]\n          });\n        });\n        this.listOfVertex = this.listOfVertex.sort((a, b) => a.range[0] - b.range[0]);\n        this.mainChartInstance.changeHeight(Math.max(this.listOfVertex.length * 50 + 100, 150));\n        this.mainChartInstance.source(this.listOfVertex, {\n          range: {\n            alias: 'Time',\n            type: 'time',\n            mask: 'HH:mm:ss',\n            nice: false\n          }\n        });\n        this.mainChartInstance.render();\n        this.cdr.markForCheck();\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  JobTimelineComponent.ɵfac = function JobTimelineComponent_Factory(t) {\n    return new (t || JobTimelineComponent)(i0.ɵɵdirectiveInject(i1.JobService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  JobTimelineComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: JobTimelineComponent,\n    selectors: [[\"flink-job-timeline\"]],\n    viewQuery: function JobTimelineComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mainTimeLine = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subTaskTimeLine = _t.first);\n      }\n    },\n    decls: 8,\n    vars: 3,\n    consts: [[\"nzText\", \"Vertex TimeLine\"], [\"mainTimeLine\", \"\"], [\"nzText\", \"SubTask TimeLine\", 4, \"ngIf\"], [1, \"name\", 3, \"hidden\"], [\"id\", \"subtask\"], [\"subTaskTimeLine\", \"\"], [\"nzText\", \"SubTask TimeLine\"]],\n    template: function JobTimelineComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"nz-divider\", 0);\n        i0.ɵɵelement(1, \"div\", null, 1);\n        i0.ɵɵtemplate(3, JobTimelineComponent_nz_divider_3_Template, 1, 0, \"nz-divider\", 2);\n        i0.ɵɵelementStart(4, \"div\", 3);\n        i0.ɵɵtext(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(6, \"div\", 4, 5);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.isShowSubTaskTimeLine);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", !ctx.isShowSubTaskTimeLine);\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(ctx.selectedName);\n      }\n    },\n    directives: [i2.NzDividerComponent, i3.NgIf],\n    styles: [\"[_nghost-%COMP%]{display:block;position:relative;background:#fff}.name[_ngcontent-%COMP%]{font-size:12px;padding:12px;word-break:break-all;background:#fafafa;border-top:1px solid #f0f0f0;border-bottom:1px solid #f0f0f0}\"],\n    changeDetection: 0\n  });\n  return JobTimelineComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}