{"ast":null,"code":"import { startOfWeek, startOfMonth, setYear, addYears, setMonth, addMonths, setDay, isSameDay, isSameSecond, isSameMinute, isSameHour, isSameMonth, isSameYear, differenceInCalendarDays, differenceInSeconds, differenceInMinutes, differenceInHours, differenceInCalendarMonths, differenceInCalendarYears, isToday, isValid, isFirstDayOfMonth, isLastDayOfMonth } from 'date-fns';\nimport { warn } from 'ng-zorro-antd/core/logger';\nimport { getLocaleDayPeriods, FormStyle, TranslationWidth } from '@angular/common';\nimport { isNotNil } from 'ng-zorro-antd/core/util';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nfunction wrongSortOrder(rangeValue) {\n  const [start, end] = rangeValue;\n  return !!start && !!end && end.isBeforeDay(start);\n}\n\nfunction normalizeRangeValue(value, hasTimePicker, type = 'month', activePart = 'left') {\n  const [start, end] = value;\n  let newStart = start || new CandyDate();\n  let newEnd = end || (hasTimePicker ? newStart : newStart.add(1, type));\n\n  if (start && !end) {\n    newStart = start;\n    newEnd = hasTimePicker ? start : start.add(1, type);\n  } else if (!start && end) {\n    newStart = hasTimePicker ? end : end.add(-1, type);\n    newEnd = end;\n  } else if (start && end && !hasTimePicker) {\n    if (start.isSame(end, type)) {\n      newEnd = newStart.add(1, type);\n    } else {\n      if (activePart === 'left') {\n        newEnd = newStart.add(1, type);\n      } else {\n        newStart = newEnd.add(-1, type);\n      }\n    }\n  }\n\n  return [newStart, newEnd];\n}\n\nfunction cloneDate(value) {\n  if (Array.isArray(value)) {\n    return value.map(v => v instanceof CandyDate ? v.clone() : null);\n  } else {\n    return value instanceof CandyDate ? value.clone() : null;\n  }\n}\n/**\n * Wrapping kind APIs for date operating and unify\n * NOTE: every new API return new CandyDate object without side effects to the former Date object\n * NOTE: most APIs are based on local time other than customized locale id (this needs tobe support in future)\n * TODO: support format() against to angular's core API\n */\n\n\nclass CandyDate {\n  // locale: string; // Custom specified locale ID\n  constructor(date) {\n    if (date) {\n      if (date instanceof Date) {\n        this.nativeDate = date;\n      } else if (typeof date === 'string' || typeof date === 'number') {\n        warn('The string type is not recommended for date-picker, use \"Date\" type');\n        this.nativeDate = new Date(date);\n      } else {\n        throw new Error('The input date type is not supported (\"Date\" is now recommended)');\n      }\n    } else {\n      this.nativeDate = new Date();\n    }\n  }\n\n  calendarStart(options) {\n    return new CandyDate(startOfWeek(startOfMonth(this.nativeDate), options));\n  } // ---------------------------------------------------------------------\n  // | Native shortcuts\n  // -----------------------------------------------------------------------------\\\n\n\n  getYear() {\n    return this.nativeDate.getFullYear();\n  }\n\n  getMonth() {\n    return this.nativeDate.getMonth();\n  }\n\n  getDay() {\n    return this.nativeDate.getDay();\n  }\n\n  getTime() {\n    return this.nativeDate.getTime();\n  }\n\n  getDate() {\n    return this.nativeDate.getDate();\n  }\n\n  getHours() {\n    return this.nativeDate.getHours();\n  }\n\n  getMinutes() {\n    return this.nativeDate.getMinutes();\n  }\n\n  getSeconds() {\n    return this.nativeDate.getSeconds();\n  }\n\n  getMilliseconds() {\n    return this.nativeDate.getMilliseconds();\n  } // ---------------------------------------------------------------------\n  // | New implementing APIs\n  // ---------------------------------------------------------------------\n\n\n  clone() {\n    return new CandyDate(new Date(this.nativeDate));\n  }\n\n  setHms(hour, minute, second) {\n    const newDate = new Date(this.nativeDate.setHours(hour, minute, second));\n    return new CandyDate(newDate);\n  }\n\n  setYear(year) {\n    return new CandyDate(setYear(this.nativeDate, year));\n  }\n\n  addYears(amount) {\n    return new CandyDate(addYears(this.nativeDate, amount));\n  } // NOTE: month starts from 0\n  // NOTE: Don't use the native API for month manipulation as it not restrict the date when it overflows, eg. (new Date('2018-7-31')).setMonth(1) will be date of 2018-3-03 instead of 2018-2-28\n\n\n  setMonth(month) {\n    return new CandyDate(setMonth(this.nativeDate, month));\n  }\n\n  addMonths(amount) {\n    return new CandyDate(addMonths(this.nativeDate, amount));\n  }\n\n  setDay(day, options) {\n    return new CandyDate(setDay(this.nativeDate, day, options));\n  }\n\n  setDate(amount) {\n    const date = new Date(this.nativeDate);\n    date.setDate(amount);\n    return new CandyDate(date);\n  }\n\n  addDays(amount) {\n    return this.setDate(this.getDate() + amount);\n  }\n\n  add(amount, mode) {\n    switch (mode) {\n      case 'decade':\n        return this.addYears(amount * 10);\n\n      case 'year':\n        return this.addYears(amount);\n\n      case 'month':\n        return this.addMonths(amount);\n\n      default:\n        return this.addMonths(amount);\n    }\n  }\n\n  isSame(date, grain = 'day') {\n    let fn;\n\n    switch (grain) {\n      case 'decade':\n        fn = (pre, next) => Math.abs(pre.getFullYear() - next.getFullYear()) < 11;\n\n        break;\n\n      case 'year':\n        fn = isSameYear;\n        break;\n\n      case 'month':\n        fn = isSameMonth;\n        break;\n\n      case 'day':\n        fn = isSameDay;\n        break;\n\n      case 'hour':\n        fn = isSameHour;\n        break;\n\n      case 'minute':\n        fn = isSameMinute;\n        break;\n\n      case 'second':\n        fn = isSameSecond;\n        break;\n\n      default:\n        fn = isSameDay;\n        break;\n    }\n\n    return fn(this.nativeDate, this.toNativeDate(date));\n  }\n\n  isSameYear(date) {\n    return this.isSame(date, 'year');\n  }\n\n  isSameMonth(date) {\n    return this.isSame(date, 'month');\n  }\n\n  isSameDay(date) {\n    return this.isSame(date, 'day');\n  }\n\n  isSameHour(date) {\n    return this.isSame(date, 'hour');\n  }\n\n  isSameMinute(date) {\n    return this.isSame(date, 'minute');\n  }\n\n  isSameSecond(date) {\n    return this.isSame(date, 'second');\n  }\n\n  isBefore(date, grain = 'day') {\n    if (date === null) {\n      return false;\n    }\n\n    let fn;\n\n    switch (grain) {\n      case 'year':\n        fn = differenceInCalendarYears;\n        break;\n\n      case 'month':\n        fn = differenceInCalendarMonths;\n        break;\n\n      case 'day':\n        fn = differenceInCalendarDays;\n        break;\n\n      case 'hour':\n        fn = differenceInHours;\n        break;\n\n      case 'minute':\n        fn = differenceInMinutes;\n        break;\n\n      case 'second':\n        fn = differenceInSeconds;\n        break;\n\n      default:\n        fn = differenceInCalendarDays;\n        break;\n    }\n\n    return fn(this.nativeDate, this.toNativeDate(date)) < 0;\n  }\n\n  isBeforeYear(date) {\n    return this.isBefore(date, 'year');\n  }\n\n  isBeforeMonth(date) {\n    return this.isBefore(date, 'month');\n  }\n\n  isBeforeDay(date) {\n    return this.isBefore(date, 'day');\n  } // Equal to today accurate to \"day\"\n\n\n  isToday() {\n    return isToday(this.nativeDate);\n  }\n\n  isValid() {\n    return isValid(this.nativeDate);\n  }\n\n  isFirstDayOfMonth() {\n    return isFirstDayOfMonth(this.nativeDate);\n  }\n\n  isLastDayOfMonth() {\n    return isLastDayOfMonth(this.nativeDate);\n  }\n\n  toNativeDate(date) {\n    return date instanceof CandyDate ? date.nativeDate : date;\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst timeUnits = [['Y', 1000 * 60 * 60 * 24 * 365], ['M', 1000 * 60 * 60 * 24 * 30], ['D', 1000 * 60 * 60 * 24], ['H', 1000 * 60 * 60], ['m', 1000 * 60], ['s', 1000], ['S', 1] // million seconds\n];\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NgTimeParser {\n  constructor(format, localeId) {\n    this.format = format;\n    this.localeId = localeId;\n    this.regex = null;\n    this.matchMap = {\n      hour: null,\n      minute: null,\n      second: null,\n      periodNarrow: null,\n      periodWide: null,\n      periodAbbreviated: null\n    };\n    this.genRegexp();\n  }\n\n  toDate(str) {\n    const result = this.getTimeResult(str);\n    const time = new Date();\n\n    if (isNotNil(result === null || result === void 0 ? void 0 : result.hour)) {\n      time.setHours(result.hour);\n    }\n\n    if (isNotNil(result === null || result === void 0 ? void 0 : result.minute)) {\n      time.setMinutes(result.minute);\n    }\n\n    if (isNotNil(result === null || result === void 0 ? void 0 : result.second)) {\n      time.setSeconds(result.second);\n    }\n\n    if ((result === null || result === void 0 ? void 0 : result.period) === 1 && time.getHours() < 12) {\n      time.setHours(time.getHours() + 12);\n    }\n\n    return time;\n  }\n\n  getTimeResult(str) {\n    const match = this.regex.exec(str);\n    let period = null;\n\n    if (match) {\n      if (isNotNil(this.matchMap.periodNarrow)) {\n        period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Narrow).indexOf(match[this.matchMap.periodNarrow + 1]);\n      }\n\n      if (isNotNil(this.matchMap.periodWide)) {\n        period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Wide).indexOf(match[this.matchMap.periodWide + 1]);\n      }\n\n      if (isNotNil(this.matchMap.periodAbbreviated)) {\n        period = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Abbreviated).indexOf(match[this.matchMap.periodAbbreviated + 1]);\n      }\n\n      return {\n        hour: isNotNil(this.matchMap.hour) ? Number.parseInt(match[this.matchMap.hour + 1], 10) : null,\n        minute: isNotNil(this.matchMap.minute) ? Number.parseInt(match[this.matchMap.minute + 1], 10) : null,\n        second: isNotNil(this.matchMap.second) ? Number.parseInt(match[this.matchMap.second + 1], 10) : null,\n        period\n      };\n    } else {\n      return null;\n    }\n  }\n\n  genRegexp() {\n    let regexStr = this.format.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$&');\n    const hourRegex = /h{1,2}/i;\n    const minuteRegex = /m{1,2}/;\n    const secondRegex = /s{1,2}/;\n    const periodNarrow = /aaaaa/;\n    const periodWide = /aaaa/;\n    const periodAbbreviated = /a{1,3}/;\n    const hourMatch = hourRegex.exec(this.format);\n    const minuteMatch = minuteRegex.exec(this.format);\n    const secondMatch = secondRegex.exec(this.format);\n    const periodNarrowMatch = periodNarrow.exec(this.format);\n    let periodWideMatch = null;\n    let periodAbbreviatedMatch = null;\n\n    if (!periodNarrowMatch) {\n      periodWideMatch = periodWide.exec(this.format);\n    }\n\n    if (!periodWideMatch && !periodNarrowMatch) {\n      periodAbbreviatedMatch = periodAbbreviated.exec(this.format);\n    }\n\n    const matchs = [hourMatch, minuteMatch, secondMatch, periodNarrowMatch, periodWideMatch, periodAbbreviatedMatch].filter(m => !!m).sort((a, b) => a.index - b.index);\n    matchs.forEach((match, index) => {\n      switch (match) {\n        case hourMatch:\n          this.matchMap.hour = index;\n          regexStr = regexStr.replace(hourRegex, '(\\\\d{1,2})');\n          break;\n\n        case minuteMatch:\n          this.matchMap.minute = index;\n          regexStr = regexStr.replace(minuteRegex, '(\\\\d{1,2})');\n          break;\n\n        case secondMatch:\n          this.matchMap.second = index;\n          regexStr = regexStr.replace(secondRegex, '(\\\\d{1,2})');\n          break;\n\n        case periodNarrowMatch:\n          this.matchMap.periodNarrow = index;\n          const periodsNarrow = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Narrow).join('|');\n          regexStr = regexStr.replace(periodNarrow, `(${periodsNarrow})`);\n          break;\n\n        case periodWideMatch:\n          this.matchMap.periodWide = index;\n          const periodsWide = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Wide).join('|');\n          regexStr = regexStr.replace(periodWide, `(${periodsWide})`);\n          break;\n\n        case periodAbbreviatedMatch:\n          this.matchMap.periodAbbreviated = index;\n          const periodsAbbreviated = getLocaleDayPeriods(this.localeId, FormStyle.Format, TranslationWidth.Abbreviated).join('|');\n          regexStr = regexStr.replace(periodAbbreviated, `(${periodsAbbreviated})`);\n          break;\n      }\n    });\n    this.regex = new RegExp(regexStr);\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CandyDate, cloneDate, normalizeRangeValue, timeUnits, wrongSortOrder, NgTimeParser as ɵNgTimeParser }; //# sourceMappingURL=ng-zorro-antd-core-time.js.map","map":null,"metadata":{},"sourceType":"module"}