{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, ElementRef, Output, Input, NgModule } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { Observable, Subject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Factory that creates a new ResizeObserver and allows us to stub it out in unit tests.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet NzResizeObserverFactory = /*#__PURE__*/(() => {\n  class NzResizeObserverFactory {\n    create(callback) {\n      return typeof ResizeObserver === 'undefined' ? null : new ResizeObserver(callback);\n    }\n\n  }\n\n  NzResizeObserverFactory.ɵfac = function NzResizeObserverFactory_Factory(t) {\n    return new (t || NzResizeObserverFactory)();\n  };\n\n  NzResizeObserverFactory.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function NzResizeObserverFactory_Factory() {\n      return new NzResizeObserverFactory();\n    },\n    token: NzResizeObserverFactory,\n    providedIn: \"root\"\n  });\n  /** An injectable service that allows watching elements for changes to their content. */\n\n  return NzResizeObserverFactory;\n})();\nlet NzResizeObserver = /*#__PURE__*/(() => {\n  class NzResizeObserver {\n    constructor(nzResizeObserverFactory) {\n      this.nzResizeObserverFactory = nzResizeObserverFactory;\n      /** Keeps track of the existing ResizeObservers so they can be reused. */\n\n      this.observedElements = new Map();\n    }\n\n    ngOnDestroy() {\n      this.observedElements.forEach((_, element) => this.cleanupObserver(element));\n    }\n\n    observe(elementOrRef) {\n      const element = coerceElement(elementOrRef);\n      return new Observable(observer => {\n        const stream = this.observeElement(element);\n        const subscription = stream.subscribe(observer);\n        return () => {\n          subscription.unsubscribe();\n          this.unobserveElement(element);\n        };\n      });\n    }\n    /**\n     * Observes the given element by using the existing ResizeObserver if available, or creating a\n     * new one if not.\n     */\n\n\n    observeElement(element) {\n      if (!this.observedElements.has(element)) {\n        const stream = new Subject();\n        const observer = this.nzResizeObserverFactory.create(mutations => stream.next(mutations));\n\n        if (observer) {\n          observer.observe(element);\n        }\n\n        this.observedElements.set(element, {\n          observer,\n          stream,\n          count: 1\n        });\n      } else {\n        this.observedElements.get(element).count++;\n      }\n\n      return this.observedElements.get(element).stream;\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying ResizeObserver if nobody else is\n     * observing this element.\n     */\n\n\n    unobserveElement(element) {\n      if (this.observedElements.has(element)) {\n        this.observedElements.get(element).count--;\n\n        if (!this.observedElements.get(element).count) {\n          this.cleanupObserver(element);\n        }\n      }\n    }\n    /** Clean up the underlying ResizeObserver for the specified element. */\n\n\n    cleanupObserver(element) {\n      if (this.observedElements.has(element)) {\n        const {\n          observer,\n          stream\n        } = this.observedElements.get(element);\n\n        if (observer) {\n          observer.disconnect();\n        }\n\n        stream.complete();\n        this.observedElements.delete(element);\n      }\n    }\n\n  }\n\n  NzResizeObserver.ɵfac = function NzResizeObserver_Factory(t) {\n    return new (t || NzResizeObserver)(ɵngcc0.ɵɵinject(NzResizeObserverFactory));\n  };\n\n  NzResizeObserver.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function NzResizeObserver_Factory() {\n      return new NzResizeObserver(i0.ɵɵinject(NzResizeObserverFactory));\n    },\n    token: NzResizeObserver,\n    providedIn: \"root\"\n  });\n  return NzResizeObserver;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzResizeObserverDirective = /*#__PURE__*/(() => {\n  class NzResizeObserverDirective {\n    constructor(nzResizeObserver, elementRef) {\n      this.nzResizeObserver = nzResizeObserver;\n      this.elementRef = elementRef;\n      this.nzResizeObserve = new EventEmitter();\n      this.nzResizeObserverDisabled = false;\n      this.currentSubscription = null;\n    }\n\n    subscribe() {\n      this.unsubscribe();\n      this.currentSubscription = this.nzResizeObserver.observe(this.elementRef).subscribe(this.nzResizeObserve);\n    }\n\n    unsubscribe() {\n      var _a;\n\n      (_a = this.currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n\n    ngAfterContentInit() {\n      if (!this.currentSubscription && !this.nzResizeObserverDisabled) {\n        this.subscribe();\n      }\n    }\n\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzResizeObserve\n      } = changes;\n\n      if (nzResizeObserve) {\n        if (this.nzResizeObserverDisabled) {\n          this.unsubscribe();\n        } else {\n          this.subscribe();\n        }\n      }\n    }\n\n  }\n\n  NzResizeObserverDirective.ɵfac = function NzResizeObserverDirective_Factory(t) {\n    return new (t || NzResizeObserverDirective)(ɵngcc0.ɵɵdirectiveInject(NzResizeObserver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  NzResizeObserverDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzResizeObserverDirective,\n    selectors: [[\"\", \"nzResizeObserver\", \"\"]],\n    inputs: {\n      nzResizeObserverDisabled: \"nzResizeObserverDisabled\"\n    },\n    outputs: {\n      nzResizeObserve: \"nzResizeObserve\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([InputBoolean()], NzResizeObserverDirective.prototype, \"nzResizeObserverDisabled\", void 0);\n\n  return NzResizeObserverDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzResizeObserverModule = /*#__PURE__*/(() => {\n  class NzResizeObserverModule {}\n\n  NzResizeObserverModule.ɵfac = function NzResizeObserverModule_Factory(t) {\n    return new (t || NzResizeObserverModule)();\n  };\n\n  NzResizeObserverModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NzResizeObserverModule\n  });\n  NzResizeObserverModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [NzResizeObserverFactory]\n  });\n  return NzResizeObserverModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzResizeObserverModule, {\n    declarations: [NzResizeObserverDirective],\n    exports: [NzResizeObserverDirective]\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzResizeObserver, NzResizeObserverDirective, NzResizeObserverFactory, NzResizeObserverModule }; //# sourceMappingURL=ng-zorro-antd-cdk-resize-observer.js.map","map":null,"metadata":{},"sourceType":"module"}