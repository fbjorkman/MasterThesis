{"ast":null,"code":"import { map } from 'rxjs/operators';\nimport { BASE_URL, LONG_MIN_VALUE } from 'config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let MetricsService = /*#__PURE__*/(() => {\n  class MetricsService {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n    }\n    /**\n     * Get available metric list\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    getAllAvailableMetrics(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/metrics`).pipe(map(item => item.sort((pre, next) => {\n        const preId = pre.id.toLowerCase();\n        const nextId = next.id.toLowerCase();\n\n        if (preId < nextId) {\n          return -1;\n        } else if (preId > nextId) {\n          return 1;\n        } else {\n          return 0;\n        }\n      })));\n    }\n    /**\n     * Get metric data\n     * @param jobId\n     * @param vertexId\n     * @param listOfMetricName\n     */\n\n\n    getMetrics(jobId, vertexId, listOfMetricName) {\n      const metricName = listOfMetricName.join(',');\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/metrics?get=${metricName}`).pipe(map(arr => {\n        const result = {};\n        arr.forEach(item => {\n          result[item.id] = parseInt(item.value, 10);\n        });\n        return {\n          timestamp: Date.now(),\n          values: result\n        };\n      }));\n    }\n    /**\n     * Get aggregated metric data from all subtasks of the given vertexId\n     * @param jobId\n     * @param vertexId\n     * @param listOfMetricName\n     */\n\n\n    getAggregatedMetrics(jobId, vertexId, listOfMetricName, aggregate = \"max\") {\n      const metricName = listOfMetricName.join(',');\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/subtasks/metrics?get=${metricName}`).pipe(map(arr => {\n        const result = {};\n        arr.forEach(item => {\n          switch (aggregate) {\n            case \"min\":\n              result[item.id] = +item.min;\n              break;\n\n            case \"max\":\n              result[item.id] = +item.max;\n              break;\n\n            case \"avg\":\n              result[item.id] = +item.avg;\n              break;\n\n            case \"sum\":\n              result[item.id] = +item.sum;\n              break;\n\n            default:\n              throw new Error(\"Unsupported aggregate: \" + aggregate);\n          }\n        });\n        return result;\n      }));\n    }\n    /**\n     * Gets the watermarks for a given vertex id.\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    getWatermarks(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/watermarks`).pipe(map(arr => {\n        let minValue = NaN;\n        let lowWatermark = NaN;\n        const watermarks = {};\n        arr.forEach(item => {\n          const value = parseInt(item.value, 10);\n          const subTaskIndex = item.id.replace('.currentInputWatermark', '');\n          watermarks[subTaskIndex] = value;\n\n          if (isNaN(minValue) || value < minValue) {\n            minValue = value;\n          }\n        });\n\n        if (!isNaN(minValue) && minValue > LONG_MIN_VALUE) {\n          lowWatermark = minValue;\n        } else {\n          lowWatermark = NaN;\n        }\n\n        return {\n          lowWatermark,\n          watermarks\n        };\n      }));\n    }\n\n  }\n\n  MetricsService.ɵfac = function MetricsService_Factory(t) {\n    return new (t || MetricsService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  MetricsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MetricsService,\n    factory: MetricsService.ɵfac,\n    providedIn: 'root'\n  });\n  return MetricsService;\n})();","map":null,"metadata":{},"sourceType":"module"}