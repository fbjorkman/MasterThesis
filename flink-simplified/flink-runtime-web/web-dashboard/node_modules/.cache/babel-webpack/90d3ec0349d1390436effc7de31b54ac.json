{"ast":null,"code":"import { __decorate } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Directive, Optional, Self, Renderer2, ElementRef, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, ContentChildren, NgZone, isDevMode, ContentChild, NgModule } from '@angular/core';\nimport { Subject, merge, EMPTY } from 'rxjs';\nimport { filter, takeUntil, startWith, switchMap, mergeMap, map } from 'rxjs/operators';\nimport { InputBoolean, isNotNil } from 'ng-zorro-antd/core/util';\nimport { NgControl } from '@angular/forms';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport { NzResizeService } from 'ng-zorro-antd/core/services';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@angular/cdk/bidi';\nimport * as ɵngcc3 from '@angular/cdk/a11y';\nimport * as ɵngcc4 from '@angular/common';\nimport * as ɵngcc5 from '@angular/cdk/platform';\nimport * as ɵngcc6 from 'ng-zorro-antd/core/services';\nimport * as ɵngcc7 from 'ng-zorro-antd/core/outlet';\nimport * as ɵngcc8 from 'ng-zorro-antd/icon';\n\nfunction NzInputGroupComponent_span_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"icon\", ctx_r7.nzAddOnBeforeIcon)(\"template\", ctx_r7.nzAddOnBefore);\n  }\n}\n\nfunction NzInputGroupComponent_span_0_span_2_ng_template_1_Template(rf, ctx) {}\n\nfunction NzInputGroupComponent_span_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 8);\n    ɵngcc0.ɵɵtemplate(1, NzInputGroupComponent_span_0_span_2_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n\n    const _r3 = ɵngcc0.ɵɵreference(4);\n\n    ɵngcc0.ɵɵclassProp(\"ant-input-affix-wrapper-sm\", ctx_r8.isSmall)(\"ant-input-affix-wrapper-lg\", ctx_r8.isLarge);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction NzInputGroupComponent_span_0_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"icon\", ctx_r9.nzAddOnAfterIcon)(\"template\", ctx_r9.nzAddOnAfter);\n  }\n}\n\nfunction NzInputGroupComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtemplate(1, NzInputGroupComponent_span_0_span_1_Template, 1, 2, \"span\", 5);\n    ɵngcc0.ɵɵtemplate(2, NzInputGroupComponent_span_0_span_2_Template, 2, 5, \"span\", 6);\n    ɵngcc0.ɵɵtemplate(3, NzInputGroupComponent_span_0_span_3_Template, 1, 2, \"span\", 5);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n\n    const _r5 = ɵngcc0.ɵɵreference(6);\n\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.nzAddOnBefore || ctx_r0.nzAddOnBeforeIcon);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.isAffix)(\"ngIfElse\", _r5);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.nzAddOnAfter || ctx_r0.nzAddOnAfterIcon);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template(rf, ctx) {}\n\nfunction NzInputGroupComponent_ng_template_1_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n\n  if (rf & 2) {\n    ɵngcc0.ɵɵnextContext(2);\n\n    const _r3 = ɵngcc0.ɵɵreference(4);\n\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_1_ng_template_0_Template, 1, 1, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n\n    const _r5 = ɵngcc0.ɵɵreference(6);\n\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.isAffix)(\"ngIfElse\", _r5);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_3_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 13);\n  }\n\n  if (rf & 2) {\n    const ctx_r13 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"icon\", ctx_r13.nzPrefixIcon)(\"template\", ctx_r13.nzPrefix);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_3_ng_template_1_Template(rf, ctx) {}\n\nfunction NzInputGroupComponent_ng_template_3_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r15 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"icon\", ctx_r15.nzSuffixIcon)(\"template\", ctx_r15.nzSuffix);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, NzInputGroupComponent_ng_template_3_span_0_Template, 1, 2, \"span\", 11);\n    ɵngcc0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_3_ng_template_1_Template, 0, 0, \"ng-template\", 9);\n    ɵngcc0.ɵɵtemplate(2, NzInputGroupComponent_ng_template_3_span_2_Template, 1, 2, \"span\", 12);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext();\n\n    const _r5 = ɵngcc0.ɵɵreference(6);\n\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r4.nzPrefix || ctx_r4.nzPrefixIcon);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r4.nzSuffix || ctx_r4.nzSuffixIcon);\n  }\n}\n\nfunction NzInputGroupComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0);\n  }\n}\n\nconst _c0 = [\"*\"];\nconst _c1 = [\"nz-input-group-slot\", \"\"];\n\nfunction NzInputGroupSlotComponent_i_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"i\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"nzType\", ctx_r0.icon);\n  }\n}\n\nfunction NzInputGroupSlotComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.template);\n  }\n}\n\nconst _c2 = [[[\"textarea\", \"nz-input\", \"\"]]];\nconst _c3 = [\"textarea[nz-input]\"];\nlet NzInputDirective = /*#__PURE__*/(() => {\n  class NzInputDirective {\n    constructor(ngControl, renderer, elementRef, directionality) {\n      this.ngControl = ngControl;\n      this.directionality = directionality;\n      this.nzBorderless = false;\n      this.nzSize = 'default';\n      this._disabled = false;\n      this.disabled$ = new Subject();\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n      renderer.addClass(elementRef.nativeElement, 'ant-input');\n    }\n\n    get disabled() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value != null && `${value}` !== 'false';\n    }\n\n    ngOnInit() {\n      var _a, _b;\n\n      if (this.ngControl) {\n        (_a = this.ngControl.statusChanges) === null || _a === void 0 ? void 0 : _a.pipe(filter(() => this.ngControl.disabled !== null), takeUntil(this.destroy$)).subscribe(() => {\n          this.disabled$.next(this.ngControl.disabled);\n        });\n      }\n\n      this.dir = this.directionality.value;\n      (_b = this.directionality.change) === null || _b === void 0 ? void 0 : _b.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n\n    ngOnChanges(changes) {\n      const {\n        disabled\n      } = changes;\n\n      if (disabled) {\n        this.disabled$.next(this.disabled);\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzInputDirective.ɵfac = function NzInputDirective_Factory(t) {\n    return new (t || NzInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  NzInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzInputDirective,\n    selectors: [[\"input\", \"nz-input\", \"\"], [\"textarea\", \"nz-input\", \"\"]],\n    hostVars: 11,\n    hostBindings: function NzInputDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"disabled\", ctx.disabled || null);\n        ɵngcc0.ɵɵclassProp(\"ant-input-disabled\", ctx.disabled)(\"ant-input-borderless\", ctx.nzBorderless)(\"ant-input-lg\", ctx.nzSize === \"large\")(\"ant-input-sm\", ctx.nzSize === \"small\")(\"ant-input-rtl\", ctx.dir === \"rtl\");\n      }\n    },\n    inputs: {\n      nzBorderless: \"nzBorderless\",\n      nzSize: \"nzSize\",\n      disabled: \"disabled\"\n    },\n    exportAs: [\"nzInput\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([InputBoolean()], NzInputDirective.prototype, \"nzBorderless\", void 0);\n  /**\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n   */\n\n\n  return NzInputDirective;\n})();\nlet NzInputGroupWhitSuffixOrPrefixDirective = /*#__PURE__*/(() => {\n  class NzInputGroupWhitSuffixOrPrefixDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  NzInputGroupWhitSuffixOrPrefixDirective.ɵfac = function NzInputGroupWhitSuffixOrPrefixDirective_Factory(t) {\n    return new (t || NzInputGroupWhitSuffixOrPrefixDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  NzInputGroupWhitSuffixOrPrefixDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzInputGroupWhitSuffixOrPrefixDirective,\n    selectors: [[\"nz-input-group\", \"nzSuffix\", \"\"], [\"nz-input-group\", \"nzPrefix\", \"\"]]\n  });\n  return NzInputGroupWhitSuffixOrPrefixDirective;\n})();\nlet NzInputGroupComponent = /*#__PURE__*/(() => {\n  class NzInputGroupComponent {\n    constructor(focusMonitor, elementRef, cdr, directionality) {\n      this.focusMonitor = focusMonitor;\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.directionality = directionality;\n      this.nzAddOnBeforeIcon = null;\n      this.nzAddOnAfterIcon = null;\n      this.nzPrefixIcon = null;\n      this.nzSuffixIcon = null;\n      this.nzSize = 'default';\n      this.nzSearch = false;\n      this.nzCompact = false;\n      this.isLarge = false;\n      this.isSmall = false;\n      this.isAffix = false;\n      this.isAddOn = false;\n      this.focused = false;\n      this.disabled = false;\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n    }\n\n    updateChildrenInputSize() {\n      if (this.listOfNzInputDirective) {\n        this.listOfNzInputDirective.forEach(item => item.nzSize = this.nzSize);\n      }\n    }\n\n    ngOnInit() {\n      var _a;\n\n      this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe(focusOrigin => {\n        this.focused = !!focusOrigin;\n        this.cdr.markForCheck();\n      });\n      this.dir = this.directionality.value;\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n\n    ngAfterContentInit() {\n      this.updateChildrenInputSize();\n      const listOfInputChange$ = this.listOfNzInputDirective.changes.pipe(startWith(this.listOfNzInputDirective));\n      listOfInputChange$.pipe(switchMap(list => merge(...[listOfInputChange$, ...list.map(input => input.disabled$)])), mergeMap(() => listOfInputChange$), map(list => list.some(input => input.disabled)), takeUntil(this.destroy$)).subscribe(disabled => {\n        this.disabled = disabled;\n        this.cdr.markForCheck();\n      });\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzSize,\n        nzSuffix,\n        nzPrefix,\n        nzPrefixIcon,\n        nzSuffixIcon,\n        nzAddOnAfter,\n        nzAddOnBefore,\n        nzAddOnAfterIcon,\n        nzAddOnBeforeIcon\n      } = changes;\n\n      if (nzSize) {\n        this.updateChildrenInputSize();\n        this.isLarge = this.nzSize === 'large';\n        this.isSmall = this.nzSize === 'small';\n      }\n\n      if (nzSuffix || nzPrefix || nzPrefixIcon || nzSuffixIcon) {\n        this.isAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);\n      }\n\n      if (nzAddOnAfter || nzAddOnBefore || nzAddOnAfterIcon || nzAddOnBeforeIcon) {\n        this.isAddOn = !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);\n      }\n    }\n\n    ngOnDestroy() {\n      this.focusMonitor.stopMonitoring(this.elementRef);\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzInputGroupComponent.ɵfac = function NzInputGroupComponent_Factory(t) {\n    return new (t || NzInputGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  NzInputGroupComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NzInputGroupComponent,\n    selectors: [[\"nz-input-group\"]],\n    contentQueries: function NzInputGroupComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, NzInputDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listOfNzInputDirective = _t);\n      }\n    },\n    hostVars: 40,\n    hostBindings: function NzInputGroupComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ant-input-group-compact\", ctx.nzCompact)(\"ant-input-search-enter-button\", ctx.nzSearch)(\"ant-input-search\", ctx.nzSearch)(\"ant-input-search-rtl\", ctx.dir === \"rtl\")(\"ant-input-search-sm\", ctx.nzSearch && ctx.isSmall)(\"ant-input-search-large\", ctx.nzSearch && ctx.isLarge)(\"ant-input-group-wrapper\", ctx.isAddOn)(\"ant-input-group-wrapper-rtl\", ctx.dir === \"rtl\")(\"ant-input-group-wrapper-lg\", ctx.isAddOn && ctx.isLarge)(\"ant-input-group-wrapper-sm\", ctx.isAddOn && ctx.isSmall)(\"ant-input-affix-wrapper\", ctx.isAffix && !ctx.isAddOn)(\"ant-input-affix-wrapper-rtl\", ctx.dir === \"rtl\")(\"ant-input-affix-wrapper-focused\", ctx.isAffix && ctx.focused)(\"ant-input-affix-wrapper-disabled\", ctx.isAffix && ctx.disabled)(\"ant-input-affix-wrapper-lg\", ctx.isAffix && !ctx.isAddOn && ctx.isLarge)(\"ant-input-affix-wrapper-sm\", ctx.isAffix && !ctx.isAddOn && ctx.isSmall)(\"ant-input-group\", !ctx.isAffix && !ctx.isAddOn)(\"ant-input-group-rtl\", ctx.dir === \"rtl\")(\"ant-input-group-lg\", !ctx.isAffix && !ctx.isAddOn && ctx.isLarge)(\"ant-input-group-sm\", !ctx.isAffix && !ctx.isAddOn && ctx.isSmall);\n      }\n    },\n    inputs: {\n      nzAddOnBeforeIcon: \"nzAddOnBeforeIcon\",\n      nzAddOnAfterIcon: \"nzAddOnAfterIcon\",\n      nzPrefixIcon: \"nzPrefixIcon\",\n      nzSuffixIcon: \"nzSuffixIcon\",\n      nzSize: \"nzSize\",\n      nzSearch: \"nzSearch\",\n      nzCompact: \"nzCompact\",\n      nzAddOnBefore: \"nzAddOnBefore\",\n      nzAddOnAfter: \"nzAddOnAfter\",\n      nzPrefix: \"nzPrefix\",\n      nzSuffix: \"nzSuffix\"\n    },\n    exportAs: [\"nzInputGroup\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 7,\n    vars: 2,\n    consts: [[\"class\", \"ant-input-wrapper ant-input-group\", 4, \"ngIf\", \"ngIfElse\"], [\"noAddOnTemplate\", \"\"], [\"affixTemplate\", \"\"], [\"contentTemplate\", \"\"], [1, \"ant-input-wrapper\", \"ant-input-group\"], [\"nz-input-group-slot\", \"\", \"type\", \"addon\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"class\", \"ant-input-affix-wrapper\", 3, \"ant-input-affix-wrapper-sm\", \"ant-input-affix-wrapper-lg\", 4, \"ngIf\", \"ngIfElse\"], [\"nz-input-group-slot\", \"\", \"type\", \"addon\", 3, \"icon\", \"template\"], [1, \"ant-input-affix-wrapper\"], [3, \"ngTemplateOutlet\"], [3, \"ngIf\", \"ngIfElse\"], [\"nz-input-group-slot\", \"\", \"type\", \"prefix\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\", 3, \"icon\", \"template\", 4, \"ngIf\"], [\"nz-input-group-slot\", \"\", \"type\", \"prefix\", 3, \"icon\", \"template\"], [\"nz-input-group-slot\", \"\", \"type\", \"suffix\", 3, \"icon\", \"template\"]],\n    template: function NzInputGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, NzInputGroupComponent_span_0_Template, 4, 4, \"span\", 0);\n        ɵngcc0.ɵɵtemplate(1, NzInputGroupComponent_ng_template_1_Template, 1, 2, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(3, NzInputGroupComponent_ng_template_3_Template, 3, 3, \"ng-template\", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(5, NzInputGroupComponent_ng_template_5_Template, 1, 0, \"ng-template\", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(2);\n\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isAddOn)(\"ngIfElse\", _r1);\n      }\n    },\n    directives: function () {\n      return [ɵngcc4.NgIf, NzInputGroupSlotComponent, ɵngcc4.NgTemplateOutlet];\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzInputGroupComponent.prototype, \"nzSearch\", void 0);\n\n  __decorate([InputBoolean()], NzInputGroupComponent.prototype, \"nzCompact\", void 0);\n\n  return NzInputGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzAutosizeDirective = /*#__PURE__*/(() => {\n  class NzAutosizeDirective {\n    constructor(elementRef, ngZone, platform, resizeService) {\n      this.elementRef = elementRef;\n      this.ngZone = ngZone;\n      this.platform = platform;\n      this.resizeService = resizeService;\n      this.autosize = false;\n      this.el = this.elementRef.nativeElement;\n      this.maxHeight = null;\n      this.minHeight = null;\n      this.destroy$ = new Subject();\n      this.inputGap = 10;\n    }\n\n    set nzAutosize(value) {\n      const isAutoSizeType = data => typeof data !== 'string' && typeof data !== 'boolean' && (!!data.maxRows || !!data.minRows);\n\n      if (typeof value === 'string' || value === true) {\n        this.autosize = true;\n      } else if (isAutoSizeType(value)) {\n        this.autosize = true;\n        this.minRows = value.minRows;\n        this.maxRows = value.maxRows;\n        this.maxHeight = this.setMaxHeight();\n        this.minHeight = this.setMinHeight();\n      }\n    }\n\n    resizeToFitContent(force = false) {\n      this.cacheTextareaLineHeight(); // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n      // in checking the height of the textarea.\n\n      if (!this.cachedLineHeight) {\n        return;\n      }\n\n      const textarea = this.el;\n      const value = textarea.value; // Only resize if the value or minRows have changed since these calculations can be expensive.\n\n      if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {\n        return;\n      }\n\n      const placeholderText = textarea.placeholder; // Reset the textarea height to auto in order to shrink back to its default size.\n      // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n      // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n      // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n      // need to be removed temporarily.\n\n      textarea.classList.add('nz-textarea-autosize-measuring');\n      textarea.placeholder = '';\n      let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight + this.inputGap;\n\n      if (this.maxHeight !== null && height > this.maxHeight) {\n        height = this.maxHeight;\n      }\n\n      if (this.minHeight !== null && height < this.minHeight) {\n        height = this.minHeight;\n      } // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n\n\n      textarea.style.height = `${height}px`;\n      textarea.classList.remove('nz-textarea-autosize-measuring');\n      textarea.placeholder = placeholderText; // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n      // We need to re-set the selection in order for it to scroll to the proper position.\n\n      if (typeof requestAnimationFrame !== 'undefined') {\n        this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {\n          const {\n            selectionStart,\n            selectionEnd\n          } = textarea; // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n          // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n          // between the time we requested the animation frame and when it was executed.\n          // Also note that we have to assert that the textarea is focused before we set the\n          // selection range. Setting the selection range on a non-focused textarea will cause\n          // it to receive focus on IE and Edge.\n\n          if (!this.destroy$.isStopped && document.activeElement === textarea) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }));\n      }\n\n      this.previousValue = value;\n      this.previousMinRows = this.minRows;\n    }\n\n    cacheTextareaLineHeight() {\n      if (this.cachedLineHeight >= 0 || !this.el.parentNode) {\n        return;\n      } // Use a clone element because we have to override some styles.\n\n\n      const textareaClone = this.el.cloneNode(false);\n      textareaClone.rows = 1; // Use `position: absolute` so that this doesn't cause a browser layout and use\n      // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n      // would affect the height.\n\n      textareaClone.style.position = 'absolute';\n      textareaClone.style.visibility = 'hidden';\n      textareaClone.style.border = 'none';\n      textareaClone.style.padding = '0';\n      textareaClone.style.height = '';\n      textareaClone.style.minHeight = '';\n      textareaClone.style.maxHeight = ''; // In Firefox it happens that textarea elements are always bigger than the specified amount\n      // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n      // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n      // to hidden. This ensures that there is no invalid calculation of the line height.\n      // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n\n      textareaClone.style.overflow = 'hidden';\n      this.el.parentNode.appendChild(textareaClone);\n      this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;\n      this.el.parentNode.removeChild(textareaClone); // Min and max heights have to be re-calculated if the cached line height changes\n\n      this.maxHeight = this.setMaxHeight();\n      this.minHeight = this.setMinHeight();\n    }\n\n    setMinHeight() {\n      const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;\n\n      if (minHeight !== null) {\n        this.el.style.minHeight = `${minHeight}px`;\n      }\n\n      return minHeight;\n    }\n\n    setMaxHeight() {\n      const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;\n\n      if (maxHeight !== null) {\n        this.el.style.maxHeight = `${maxHeight}px`;\n      }\n\n      return maxHeight;\n    }\n\n    noopInputHandler() {// no-op handler that ensures we're running change detection on input events.\n    }\n\n    ngAfterViewInit() {\n      if (this.autosize && this.platform.isBrowser) {\n        this.resizeToFitContent();\n        this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeToFitContent(true));\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    ngDoCheck() {\n      if (this.autosize && this.platform.isBrowser) {\n        this.resizeToFitContent();\n      }\n    }\n\n  }\n\n  NzAutosizeDirective.ɵfac = function NzAutosizeDirective_Factory(t) {\n    return new (t || NzAutosizeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.NzResizeService));\n  };\n\n  NzAutosizeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NzAutosizeDirective,\n    selectors: [[\"textarea\", \"nzAutosize\", \"\"]],\n    hostAttrs: [\"rows\", \"1\"],\n    hostBindings: function NzAutosizeDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function NzAutosizeDirective_input_HostBindingHandler() {\n          return ctx.noopInputHandler();\n        });\n      }\n    },\n    inputs: {\n      nzAutosize: \"nzAutosize\"\n    },\n    exportAs: [\"nzAutosize\"]\n  });\n  return NzAutosizeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzInputGroupSlotComponent = /*#__PURE__*/(() => {\n  class NzInputGroupSlotComponent {\n    constructor() {\n      this.icon = null;\n      this.type = null;\n      this.template = null;\n    }\n\n  }\n\n  NzInputGroupSlotComponent.ɵfac = function NzInputGroupSlotComponent_Factory(t) {\n    return new (t || NzInputGroupSlotComponent)();\n  };\n\n  NzInputGroupSlotComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NzInputGroupSlotComponent,\n    selectors: [[\"\", \"nz-input-group-slot\", \"\"]],\n    hostVars: 6,\n    hostBindings: function NzInputGroupSlotComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ant-input-group-addon\", ctx.type === \"addon\")(\"ant-input-prefix\", ctx.type === \"prefix\")(\"ant-input-suffix\", ctx.type === \"suffix\");\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      type: \"type\",\n      template: \"template\"\n    },\n    attrs: _c1,\n    decls: 2,\n    vars: 2,\n    consts: [[\"nz-icon\", \"\", 3, \"nzType\", 4, \"ngIf\"], [4, \"nzStringTemplateOutlet\"], [\"nz-icon\", \"\", 3, \"nzType\"]],\n    template: function NzInputGroupSlotComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, NzInputGroupSlotComponent_i_0_Template, 1, 1, \"i\", 0);\n        ɵngcc0.ɵɵtemplate(1, NzInputGroupSlotComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.icon);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"nzStringTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [ɵngcc4.NgIf, ɵngcc7.NzStringTemplateOutletDirective, ɵngcc8.NzIconDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzInputGroupSlotComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTextareaCountComponent = /*#__PURE__*/(() => {\n  class NzTextareaCountComponent {\n    constructor(renderer, elementRef) {\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.nzMaxCharacterCount = 0;\n\n      this.nzComputeCharacterCount = v => v.length;\n\n      this.nzFormatter = (c, m) => `${c}${m > 0 ? `/${m}` : ``}`;\n\n      this.configChange$ = new Subject();\n      this.destroy$ = new Subject();\n    }\n\n    ngAfterContentInit() {\n      if (!this.nzInputDirective && isDevMode()) {\n        throw new Error('[nz-textarea-count]: Could not find matching textarea[nz-input] child.');\n      }\n\n      if (this.nzInputDirective.ngControl) {\n        const valueChanges = this.nzInputDirective.ngControl.valueChanges || EMPTY;\n        merge(valueChanges, this.configChange$).pipe(takeUntil(this.destroy$), map(() => this.nzInputDirective.ngControl.value), startWith(this.nzInputDirective.ngControl.value)).subscribe(value => {\n          this.setDataCount(value);\n        });\n      }\n    }\n\n    setDataCount(value) {\n      const inputValue = isNotNil(value) ? String(value) : '';\n      const currentCount = this.nzComputeCharacterCount(inputValue);\n      const dataCount = this.nzFormatter(currentCount, this.nzMaxCharacterCount);\n      this.renderer.setAttribute(this.elementRef.nativeElement, 'data-count', dataCount);\n    }\n\n    ngOnDestroy() {\n      this.configChange$.complete();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzTextareaCountComponent.ɵfac = function NzTextareaCountComponent_Factory(t) {\n    return new (t || NzTextareaCountComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  NzTextareaCountComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NzTextareaCountComponent,\n    selectors: [[\"nz-textarea-count\"]],\n    contentQueries: function NzTextareaCountComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, NzInputDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nzInputDirective = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ant-input-textarea-show-count\"],\n    inputs: {\n      nzMaxCharacterCount: \"nzMaxCharacterCount\",\n      nzComputeCharacterCount: \"nzComputeCharacterCount\",\n      nzFormatter: \"nzFormatter\"\n    },\n    ngContentSelectors: _c3,\n    decls: 1,\n    vars: 0,\n    template: function NzTextareaCountComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c2);\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzTextareaCountComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzInputModule = /*#__PURE__*/(() => {\n  class NzInputModule {}\n\n  NzInputModule.ɵfac = function NzInputModule_Factory(t) {\n    return new (t || NzInputModule)();\n  };\n\n  NzInputModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NzInputModule\n  });\n  NzInputModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, NzIconModule, PlatformModule, NzOutletModule]]\n  });\n  return NzInputModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzInputModule, {\n    declarations: function () {\n      return [NzTextareaCountComponent, NzInputDirective, NzInputGroupComponent, NzAutosizeDirective, NzInputGroupSlotComponent, NzInputGroupWhitSuffixOrPrefixDirective];\n    },\n    imports: function () {\n      return [BidiModule, CommonModule, NzIconModule, PlatformModule, NzOutletModule];\n    },\n    exports: function () {\n      return [NzTextareaCountComponent, NzInputDirective, NzInputGroupComponent, NzAutosizeDirective, NzInputGroupWhitSuffixOrPrefixDirective];\n    }\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzAutosizeDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupSlotComponent, NzInputGroupWhitSuffixOrPrefixDirective, NzInputModule, NzTextareaCountComponent }; //# sourceMappingURL=ng-zorro-antd-input.js.map","map":null,"metadata":{},"sourceType":"module"}