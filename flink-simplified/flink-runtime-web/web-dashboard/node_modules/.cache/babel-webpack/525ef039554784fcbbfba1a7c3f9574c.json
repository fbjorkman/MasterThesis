{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from '@angular/core';\nimport { select } from 'd3-selection';\nimport { zoomIdentity } from 'd3-zoom';\nimport { NzGraph } from './graph';\nimport { NodeComponent } from './node.component';\nimport { SvgContainerComponent } from './svg-container.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./svg-container.component\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"ng-zorro-antd/slider\";\nimport * as i4 from \"@angular/forms\";\nimport * as i5 from \"./node.component\";\nconst _c0 = [\"graphElement\"];\nconst _c1 = [\"overlayElement\"];\nconst _c2 = [\"nodeElement\"];\nconst _c3 = [\"linkElement\"];\n\nfunction DagreComponent__svg_g_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 11, 12);\n    i0.ɵɵelement(2, \"path\", 13);\n    i0.ɵɵelementStart(3, \"text\", 14);\n    i0.ɵɵelementStart(4, \"textPath\", 15);\n    i0.ɵɵtext(5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const link_r4 = ctx.$implicit;\n    i0.ɵɵproperty(\"id\", link_r4.id);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"focused\", link_r4.options == null ? null : link_r4.options.focused);\n    i0.ɵɵproperty(\"id\", \"link-\" + link_r4.id);\n    i0.ɵɵattribute(\"marker-end\", \"url(#end-arrow\" + ((link_r4.options == null ? null : link_r4.options.focused) ? \"-focus\" : \"\") + \")\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"dominant-baseline\", link_r4 == null ? null : link_r4.options == null ? null : link_r4.options.dominantBaseline);\n    i0.ɵɵattribute(\"href\", \"#link-\" + link_r4.id, null, \"xlink\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate2(\" \", link_r4 == null ? null : link_r4.detail == null ? null : link_r4.detail.ship_strategy, \" \", link_r4 == null ? null : link_r4.detail == null ? null : link_r4.detail.local_strategy, \" \");\n  }\n}\n\nfunction DagreComponent__svg_g_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 16, 17);\n    i0.ɵɵlistener(\"click\", function DagreComponent__svg_g_9_Template__svg_g_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r9);\n      const node_r6 = restoredCtx.$implicit;\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.clickNode(node_r6, $event);\n    })(\"mouseenter\", function DagreComponent__svg_g_9_Template__svg_g_mouseenter_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.onNodeMouseEnter($event);\n    })(\"mouseleave\", function DagreComponent__svg_g_9_Template__svg_g_mouseleave_0_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.onNodeMouseLeave($event);\n    });\n    i0.ɵɵelement(2, \"g\", 18);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r6 = ctx.$implicit;\n    i0.ɵɵclassProp(\"focused\", node_r6.options == null ? null : node_r6.options.focused);\n    i0.ɵɵproperty(\"id\", node_r6.id);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"node\", node_r6);\n  }\n}\n\nvar Visibility = /*#__PURE__*/(() => {\n  (function (Visibility) {\n    Visibility[\"Hidden\"] = \"hidden\";\n    Visibility[\"Visible\"] = \"visible\";\n  })(Visibility || (Visibility = {}));\n\n  return Visibility;\n})();\nexport let DagreComponent = /*#__PURE__*/(() => {\n  class DagreComponent extends NzGraph {\n    constructor(cd, zone, elementRef) {\n      super();\n      this.cd = cd;\n      this.zone = zone;\n      this.elementRef = elementRef;\n      this.visibility = Visibility.Hidden;\n      this.circleNodeIds = [];\n      this.focusedLinkIds = [];\n      this.zoom = 1;\n      this.cacheTransform = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      this.oldTransform = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      this.cacheNodes = [];\n      this.cacheLinks = [];\n      this.xCenter = 2;\n      this.yCenter = 2;\n      this.nodeClick = new EventEmitter();\n    }\n    /**\n     * Update Node detail\n     * @param id\n     * @param appendNode\n     */\n\n\n    updateNode(id, appendNode) {\n      const nodes = this.rectNodeComponents;\n      const node = nodes.find(n => n.id === id);\n\n      if (node) {\n        const cacheNode = this.cacheNodes.find(n => n.id === id);\n        node.update(Object.assign(Object.assign({}, appendNode), {\n          width: cacheNode.width,\n          height: cacheNode.height\n        }));\n      }\n    }\n    /**\n     * Focus on specific node\n     * @param node\n     * @param force\n     */\n\n\n    focusNode(node, force = false) {\n      const layoutNode = this.layoutNodes.find(n => n.id === node.id);\n      this.clickNode(layoutNode, null, force, false);\n    }\n    /**\n     * Zoom to level\n     * @param value\n     */\n\n\n    zoomToLevel(value) {\n      this.svgContainer.zoomTo(value);\n    }\n    /**\n     * Move graph to center\n     */\n\n\n    moveToCenter() {\n      if (this.graph && this.graph.graph()) {\n        this.visibility = Visibility.Visible;\n        const hostDims = this.elementRef.nativeElement.getBoundingClientRect();\n        const generatedGraph = this.graph.graph();\n        this.cacheTransform.k = Math.min(hostDims.height / (generatedGraph.height + 200), hostDims.width / (generatedGraph.width + 120), 1);\n        const width = generatedGraph.width * this.cacheTransform.k;\n        const height = generatedGraph.height * this.cacheTransform.k;\n        let translateX = (hostDims.width - width) / 2;\n        let translateY = (hostDims.height - height) / 2;\n\n        if (width < 0 || height < 0) {\n          translateX = 0;\n          translateY = 0;\n        }\n\n        this.zoom = this.cacheTransform.k;\n        this.cacheTransform.x = translateX;\n        this.cacheTransform.y = translateY;\n        const t = zoomIdentity.translate(translateX, translateY).scale(this.zoom);\n        this.svgContainer.setPositionByTransform(t);\n      }\n    }\n    /**\n     * Flush graph with nodes and links\n     * @param nodes\n     * @param links\n     * @param isResizeNode\n     */\n\n\n    flush(nodes, links, isResizeNode = false) {\n      return new Promise(resolve => {\n        this.cacheNodes = [...nodes];\n        this.cacheLinks = [...links];\n        this.zone.run(() => {\n          this.selectedNodeId = null;\n          this.createGraph({\n            compound: true\n          });\n          this.setNodes(nodes);\n          this.setEdge(links);\n          requestAnimationFrame(() => {\n            this.initLayout().then(() => {\n              requestAnimationFrame(() => {\n                this.redrawLines();\n                this.redrawNodes();\n                this.moveToCenter();\n\n                if (isResizeNode) {\n                  this.visibility = Visibility.Hidden;\n                  setTimeout(() => {\n                    this.resetNodeSize().then(() => resolve());\n                  }, 300);\n                } else {\n                  resolve();\n                }\n              });\n              this.cd.markForCheck();\n            });\n          });\n        });\n      });\n    }\n\n    trackByLink(_, link) {\n      return link.id;\n    }\n\n    trackByNode(_, link) {\n      return link.id;\n    }\n    /**\n     * Calculate node size\n     */\n\n\n    resetNodeSize() {\n      this.graphElement.nativeElement.querySelectorAll(`.node-group`).forEach(nodeEle => {\n        const contentEle = nodeEle.querySelector('.content-wrap');\n\n        if (contentEle) {\n          const height = contentEle.getBoundingClientRect().height;\n          const width = contentEle.getBoundingClientRect().width;\n          const node = this.cacheNodes.find(n => n.id === nodeEle.id);\n\n          if (node) {\n            node.height = height / this.zoom + 30 + 15;\n            node.width = width / this.zoom + 30;\n          }\n        }\n      });\n      return this.flush(this.cacheNodes, this.cacheLinks, false);\n    }\n    /**\n     * Redraw all lines\n     * @param animate\n     */\n\n\n    redrawLines(animate = true) {\n      this.linkElements.map(linkEl => {\n        const l = this.layoutLinks.find(lin => lin.id === linkEl.nativeElement.id);\n\n        if (l) {\n          const linkSelection = select(linkEl.nativeElement).select('.edge');\n          linkSelection.attr('d', l.options.oldLine).attr('stroke-width', l.options.oldWidth).transition().duration(animate ? 500 : 0).attr('d', l.options.line).attr('stroke-width', l.options.width);\n        }\n      });\n    }\n    /**\n     * Redraw all nodes\n     * @param animate\n     */\n\n\n    redrawNodes(animate = true) {\n      this.nodeElements.map(nodeEl => {\n        const node = this.layoutNodes.find(n => n.id === nodeEl.nativeElement.id);\n\n        if (node) {\n          const nodeGroupSelection = select(nodeEl.nativeElement);\n\n          if (animate) {\n            nodeGroupSelection.attr('transform', `${node.options.oldTransform},scale(${node.options.oldScale}, ${node.options.oldScale})`).transition().duration(500).attr('transform', `${node.options.transform},scale(${node.options.scale}, ${node.options.scale})`);\n          } else {\n            nodeGroupSelection.attr('transform', `${node.options.transform},scale(${node.options.scale}, ${node.options.scale})`);\n          }\n        }\n      });\n    }\n    /**\n     * Click specific node\n     * @param node\n     * @param $event\n     * @param force\n     */\n\n\n    clickNode(node, $event, force = false, emit = true) {\n      if ($event) {\n        $event.stopPropagation();\n      }\n\n      if (node) {\n        if (emit) {\n          this.nodeClick.emit(node);\n        }\n\n        if (!this.selectedNodeId) {\n          this.oldTransform = Object.assign({}, this.svgContainer.containerTransform);\n        }\n\n        if (this.selectedNodeId === node.id && !force) {\n          return;\n        }\n\n        this.selectedNodeId = node.id;\n        const hostDims = this.elementRef.nativeElement.getBoundingClientRect();\n        const x = hostDims.width / this.xCenter - this.svgContainer.containerTransform.x;\n        const y = hostDims.height / this.yCenter - this.svgContainer.containerTransform.y;\n        this.zone.run(() => {\n          this.zoomFocusLayout({\n            x,\n            y,\n            transform: this.svgContainer.containerTransform,\n            nodeId: node.id,\n            zoom: this.svgContainer ? this.svgContainer.zoom : 1\n          }).then(({\n            transform,\n            focusedLinkIds,\n            circularNodeIds\n          }) => {\n            this.focusedLinkIds = [...focusedLinkIds];\n            this.circleNodeIds = [...circularNodeIds];\n            requestAnimationFrame(() => {\n              const t = zoomIdentity.translate(transform.x, transform.y).scale(transform.k);\n              this.svgContainer.setPositionByTransform(t, true);\n              this.redrawNodes(!force);\n            });\n            this.graphElement.nativeElement.appendChild(this.overlayElement.nativeElement);\n            this.graphElement.nativeElement.querySelectorAll(`.link-group`).forEach(LinkEle => {\n              if (this.focusedLinkIds.indexOf(LinkEle.id) !== -1) {\n                this.graphElement.nativeElement.appendChild(LinkEle);\n              }\n            });\n            this.graphElement.nativeElement.querySelectorAll(`.node-group`).forEach(nodeEle => {\n              if ([this.selectedNodeId, ...this.circleNodeIds].indexOf(nodeEle.id) !== -1) {\n                this.graphElement.nativeElement.appendChild(nodeEle);\n              }\n            });\n            this.cd.markForCheck();\n          });\n        });\n      }\n    }\n    /**\n     * Redraw graph\n     */\n\n\n    redrawGraph() {\n      this.selectedNodeId = null;\n      this.circleNodeIds = [];\n      this.focusedLinkIds = [];\n      this.recoveryLayout().then(() => {\n        requestAnimationFrame(() => {\n          if (this.oldTransform.x === 0 && this.oldTransform.y === 0 && this.oldTransform.k === 1) {\n            this.moveToCenter();\n          } else {\n            const t = zoomIdentity.translate(this.oldTransform.x, this.oldTransform.y).scale(this.oldTransform.k);\n            this.svgContainer.setPositionByTransform(t, true);\n            this.redrawLines();\n            this.redrawNodes();\n          }\n        });\n        this.cd.markForCheck();\n      });\n    }\n    /**\n     * Handle svg container transform event\n     * @param $event\n     */\n\n\n    onTransform($event) {\n      this.cd.detectChanges();\n      this.cacheTransform.x = $event.x;\n      this.cacheTransform.y = $event.y;\n      this.cacheTransform.k = $event.k;\n      this.zoom = $event.k;\n    }\n    /**\n     * Mouse enter node event\n     * @param $event\n     */\n\n\n    onNodeMouseEnter($event) {\n      this.graphElement.nativeElement.appendChild($event.target);\n      this.layoutLinks.forEach(l => {\n        if (l.id.split('-').indexOf($event.target.id) !== -1) {\n          l.options.focused = true;\n        }\n      });\n      this.cd.detectChanges();\n    }\n    /**\n     * Mouse leave node event\n     */\n\n\n    onNodeMouseLeave() {\n      this.layoutLinks.forEach(l => {\n        l.options.focused = this.focusedLinkIds.indexOf(l.id) !== -1;\n      });\n      this.graphElement.nativeElement.appendChild(this.overlayElement.nativeElement);\n      this.graphElement.nativeElement.querySelectorAll(`.link-group`).forEach(e => {\n        if (this.focusedLinkIds.indexOf(e.id) !== -1) {\n          this.graphElement.nativeElement.appendChild(e);\n        }\n      });\n      this.graphElement.nativeElement.querySelectorAll(`.node-group`).forEach(e => {\n        if ([this.selectedNodeId, ...this.circleNodeIds].indexOf(e.id) !== -1) {\n          this.graphElement.nativeElement.appendChild(e);\n        }\n      });\n      this.cd.detectChanges();\n    }\n\n  }\n\n  DagreComponent.ɵfac = function DagreComponent_Factory(t) {\n    return new (t || DagreComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  DagreComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: DagreComponent,\n    selectors: [[\"flink-dagre\"]],\n    viewQuery: function DagreComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(SvgContainerComponent, 7);\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 5);\n        i0.ɵɵviewQuery(_c3, 5);\n        i0.ɵɵviewQuery(NodeComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.svgContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.graphElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlayElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeElements = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkElements = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rectNodeComponents = _t);\n      }\n    },\n    inputs: {\n      xCenter: \"xCenter\",\n      yCenter: \"yCenter\"\n    },\n    outputs: {\n      nodeClick: \"nodeClick\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 13,\n    vars: 13,\n    consts: [[3, \"transformEvent\"], [1, \"graph\"], [\"graphElement\", \"\"], [\"id\", \"end-arrow\", \"viewBox\", \"1 0 10 10\", \"refX\", \"12\", \"refY\", \"3.5\", \"markerWidth\", \"10\", \"markerHeight\", \"10\", \"orient\", \"auto\", 1, \"edge-marker\"], [\"points\", \"0 0, 10 3.5, 0 7\"], [\"id\", \"end-arrow-focus\", \"viewBox\", \"1 0 10 10\", \"refX\", \"12\", \"refY\", \"3.5\", \"markerWidth\", \"10\", \"markerHeight\", \"15\", \"orient\", \"auto\", 1, \"edge-marker-focus\"], [\"class\", \"link-group\", 3, \"id\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"node-group\", 3, \"focused\", \"id\", \"click\", \"mouseenter\", \"mouseleave\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"transform\", \"scale(999999)\", \"x\", \"-1\", \"y\", \"-1\", \"width\", \"2\", \"height\", \"2\", 1, \"nodes-chart-overlay\"], [\"overlayElement\", \"\"], [\"nzVertical\", \"\", 3, \"nzTipFormatter\", \"nzMin\", \"nzMax\", \"nzStep\", \"ngModel\", \"ngModelChange\"], [1, \"link-group\", 3, \"id\"], [\"linkElement\", \"\"], [1, \"edge\", 3, \"id\"], [\"text-anchor\", \"middle\", \"dy\", \"20\", 1, \"edge-label\"], [\"startOffset\", \"50%\", 1, \"text-path\"], [1, \"node-group\", 3, \"id\", \"click\", \"mouseenter\", \"mouseleave\"], [\"nodeElement\", \"\"], [\"flink-node\", \"\", 3, \"node\"]],\n    template: function DagreComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"flink-svg-container\", 0);\n        i0.ɵɵlistener(\"transformEvent\", function DagreComponent_Template_flink_svg_container_transformEvent_0_listener($event) {\n          return ctx.onTransform($event);\n        });\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(1, \"g\", 1, 2);\n        i0.ɵɵelementStart(3, \"defs\");\n        i0.ɵɵelementStart(4, \"marker\", 3);\n        i0.ɵɵelement(5, \"polygon\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"marker\", 5);\n        i0.ɵɵelement(7, \"polygon\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, DagreComponent__svg_g_8_Template, 6, 10, \"g\", 6);\n        i0.ɵɵtemplate(9, DagreComponent__svg_g_9_Template, 3, 4, \"g\", 7);\n        i0.ɵɵelement(10, \"rect\", 8, 9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelementStart(12, \"nz-slider\", 10);\n        i0.ɵɵlistener(\"ngModelChange\", function DagreComponent_Template_nz_slider_ngModelChange_12_listener($event) {\n          return ctx.zoomToLevel($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"visibility\", ctx.visibility);\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngForOf\", ctx.layoutLinks)(\"ngForTrackBy\", ctx.trackByLink);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.layoutNodes)(\"ngForTrackBy\", ctx.trackByNode);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"active\", ctx.selectedNodeId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"nzTipFormatter\", null)(\"nzMin\", 0.1)(\"nzMax\", 5)(\"nzStep\", 0.01)(\"ngModel\", ctx.zoom);\n      }\n    },\n    directives: [i1.SvgContainerComponent, i2.NgForOf, i3.NzSliderComponent, i4.NgControlStatus, i4.NgModel, i5.NodeComponent],\n    styles: [\"[_nghost-%COMP%]{width:100%;height:100%;display:block}nz-slider[_ngcontent-%COMP%]{position:absolute;right:12px;height:200px;top:50%;margin-top:-100px}.graph[_ngcontent-%COMP%]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.graph[_ngcontent-%COMP%]   .edge-marker[_ngcontent-%COMP%]{color:rgba(0,0,0,.85);fill:rgba(0,0,0,.85)}.graph[_ngcontent-%COMP%]   .edge-marker-focus[_ngcontent-%COMP%]{color:#1890ff;fill:#1890ff}.graph[_ngcontent-%COMP%]   .edge[_ngcontent-%COMP%]{stroke:rgba(0,0,0,.85);stroke-opacity:.6;stroke-width:1px;fill:none}.graph[_ngcontent-%COMP%]   .edge.focused[_ngcontent-%COMP%]{stroke:#1890ff;stroke-linecap:round;stroke-dashoffset:0;stroke-dasharray:10;stroke-opacity:1;-webkit-animation:circle-draw .3s linear infinite;animation:circle-draw .3s linear infinite}.graph[_ngcontent-%COMP%]   .link-group[_ngcontent-%COMP%]   .edge-label[_ngcontent-%COMP%]{stroke:none;font-size:10px;fill:rgba(0,0,0,.85)}.graph[_ngcontent-%COMP%]   .panning-rect[_ngcontent-%COMP%]{fill:transparent;cursor:move}.graph[_ngcontent-%COMP%]   .nodes-chart-overlay[_ngcontent-%COMP%]{pointer-events:none;opacity:0;-webkit-transition:opacity .45s ease-in;fill:#fff}.graph[_ngcontent-%COMP%]   .nodes-chart-overlay.active[_ngcontent-%COMP%]{-webkit-opacity:.7}@-webkit-keyframes circle-draw{0%{stroke-dashoffset:20}to{stroke-dashoffset:0}}@keyframes circle-draw{0%{stroke-dashoffset:20}to{stroke-dashoffset:0}}\"],\n    changeDetection: 0\n  });\n  return DagreComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}