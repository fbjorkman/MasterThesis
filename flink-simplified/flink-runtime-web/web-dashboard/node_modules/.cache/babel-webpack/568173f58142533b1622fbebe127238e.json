{"ast":null,"code":"import { combineLatest, EMPTY, ReplaySubject } from 'rxjs';\nimport { catchError, filter, flatMap, map, tap } from 'rxjs/operators';\nimport { BASE_URL } from 'config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let JobService = /*#__PURE__*/(() => {\n  class JobService {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n      /**\n       * Current activated job\n       */\n\n      this.jobDetail$ = new ReplaySubject(1);\n      /**\n       * Current activated vertex\n       */\n\n      this.selectedVertex$ = new ReplaySubject(1);\n      /**\n       * Current activated job with vertex\n       */\n\n      this.jobWithVertex$ = combineLatest(this.jobDetail$, this.selectedVertex$).pipe(map(data => {\n        const [job, vertex] = data;\n        return {\n          job,\n          vertex\n        };\n      }), filter(data => !!data.vertex));\n      /**\n       * Selected Metric Cache\n       */\n\n      this.metricsCacheMap = new Map();\n    }\n    /**\n     * Uses the non REST-compliant GET yarn-cancel handler which is available in addition to the\n     * proper BASE_URL + \"jobs/\" + jobid + \"?mode=cancel\"\n     * @param jobId\n     */\n\n\n    cancelJob(jobId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/yarn-cancel`);\n    }\n    /**\n     * Get job list\n     */\n\n\n    loadJobs() {\n      return this.httpClient.get(`${BASE_URL}/jobs/overview`).pipe(map(data => {\n        data.jobs.forEach(job => {\n          for (const key in job.tasks) {\n            const upperCaseKey = key.toUpperCase();\n            job.tasks[upperCaseKey] = job.tasks[key];\n            delete job.tasks[key];\n          }\n\n          job.completed = ['FINISHED', 'FAILED', 'CANCELED'].indexOf(job.state) > -1;\n        });\n        return data.jobs || [];\n      }), catchError(() => EMPTY));\n    }\n    /**\n     * Load job config\n     * @param jobId\n     */\n\n\n    loadJobConfig(jobId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/config`);\n    }\n    /**\n     * Load single job detail\n     * @param jobId\n     */\n\n\n    loadJob(jobId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}`).pipe(map(job => this.convertJob(job)), tap(job => {\n        this.jobDetail$.next(job);\n      }));\n    }\n    /**\n     * Get vertex & subtask accumulators\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    loadAccumulators(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/accumulators`).pipe(flatMap(data => {\n        const accumulators = data['user-accumulators'];\n        return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/subtasks/accumulators`).pipe(map(item => {\n          const subtaskAccumulators = item.subtasks;\n          return {\n            main: accumulators,\n            subtasks: subtaskAccumulators\n          };\n        }));\n      }));\n    }\n    /**\n     * Get job exception\n     * @param jobId\n     * @param maxExceptions\n     */\n\n\n    loadExceptions(jobId, maxExceptions) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/exceptions?maxExceptions=${maxExceptions}`);\n    }\n    /**\n     * Get vertex back pressure\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    loadOperatorBackPressure(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/backpressure`);\n    }\n    /**\n     * Get vertex flame graph\n     * @param jobId\n     * @param vertexId\n     * @param type\n     */\n\n\n    loadOperatorFlameGraph(jobId, vertexId, type) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/flamegraph?type=${type}`);\n    }\n    /**\n     * Get vertex subtask\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    loadSubTasks(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}`).pipe(map(data => data && data.subtasks || []));\n    }\n    /**\n     * Get subtask timeline\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    loadSubTaskTimes(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/subtasktimes`);\n    }\n    /**\n     * Get vertex task manager list\n     * @param jobId\n     * @param vertexId\n     */\n\n\n    loadTaskManagers(jobId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/vertices/${vertexId}/taskmanagers`);\n    }\n    /**\n     * Get check point status\n     * @param jobId\n     */\n\n\n    loadCheckpointStats(jobId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/checkpoints`);\n    }\n    /**\n     * Get check point configuration\n     * @param jobId\n     */\n\n\n    loadCheckpointConfig(jobId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/checkpoints/config`);\n    }\n    /**\n     * get check point detail\n     * @param jobId\n     * @param checkPointId\n     */\n\n\n    loadCheckpointDetails(jobId, checkPointId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/checkpoints/details/${checkPointId}`);\n    }\n    /**\n     * get subtask check point detail\n     * @param jobId\n     * @param checkPointId\n     * @param vertexId\n     */\n\n\n    loadCheckpointSubtaskDetails(jobId, checkPointId, vertexId) {\n      return this.httpClient.get(`${BASE_URL}/jobs/${jobId}/checkpoints/details/${checkPointId}/subtasks/${vertexId}`);\n    }\n    /**\n     * nodes to nodes links in order to generate graph\n     * @param job\n     */\n\n\n    convertJob(job) {\n      const links = [];\n      let nodes = [];\n\n      if (job.plan.nodes.length) {\n        nodes = job.plan.nodes.map(node => {\n          let detail;\n\n          if (job.vertices && job.vertices.length) {\n            detail = job.vertices.find(vertex => vertex.id === node.id);\n          }\n\n          return Object.assign(Object.assign({}, node), {\n            detail\n          });\n        });\n        nodes.forEach(node => {\n          if (node.inputs && node.inputs.length) {\n            node.inputs.forEach(input => {\n              links.push(Object.assign(Object.assign({}, input), {\n                source: input.id,\n                target: node.id,\n                id: `${input.id}-${node.id}`\n              }));\n            });\n          }\n        });\n        const listOfVerticesId = job.vertices.map(item => item.id);\n        nodes.sort((pre, next) => listOfVerticesId.indexOf(pre.id) - listOfVerticesId.indexOf(next.id));\n      }\n\n      return Object.assign(Object.assign({}, job), {\n        plan: Object.assign(Object.assign({}, job.plan), {\n          nodes,\n          links\n        })\n      });\n    }\n\n  }\n\n  JobService.ɵfac = function JobService_Factory(t) {\n    return new (t || JobService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  JobService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: JobService,\n    factory: JobService.ɵfac,\n    providedIn: 'root'\n  });\n  return JobService;\n})();","map":null,"metadata":{},"sourceType":"module"}