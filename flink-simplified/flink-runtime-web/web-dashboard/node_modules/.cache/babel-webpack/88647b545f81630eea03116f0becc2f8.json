{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HttpRequest, HttpParams } from '@angular/common/http';\nimport { BASE_URL } from 'config';\nimport { of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let JarService = /*#__PURE__*/(() => {\n  class JarService {\n    constructor(httpClient) {\n      this.httpClient = httpClient;\n    }\n    /**\n     * Get uploaded jar list\n     */\n\n\n    loadJarList() {\n      return this.httpClient.get(`${BASE_URL}/jars`).pipe(catchError(() => {\n        return of({\n          address: '',\n          error: true,\n          files: []\n        });\n      }));\n    }\n    /**\n     * Upload jar\n     * @param fd\n     */\n\n\n    uploadJar(fd) {\n      const formData = new FormData();\n      formData.append('jarfile', fd, fd.name);\n      const req = new HttpRequest('POST', `${BASE_URL}/jars/upload`, formData, {\n        reportProgress: true\n      });\n      return this.httpClient.request(req);\n    }\n    /**\n     * Delete jar\n     * @param jarId\n     */\n\n\n    deleteJar(jarId) {\n      return this.httpClient.delete(`${BASE_URL}/jars/${jarId}`);\n    }\n    /**\n     * Run job\n     * @param jarId\n     * @param entryClass\n     * @param parallelism\n     * @param programArgs\n     * @param savepointPath\n     * @param allowNonRestoredState\n     */\n\n\n    runJob(jarId, entryClass, parallelism, programArgs, savepointPath, allowNonRestoredState) {\n      const requestParam = {\n        entryClass,\n        parallelism,\n        programArgs,\n        savepointPath,\n        allowNonRestoredState\n      };\n      let params = new HttpParams();\n\n      if (entryClass) {\n        params = params.append('entry-class', entryClass);\n      }\n\n      if (parallelism) {\n        params = params.append('parallelism', parallelism);\n      }\n\n      if (programArgs) {\n        params = params.append('program-args', programArgs);\n      }\n\n      if (savepointPath) {\n        params = params.append('savepointPath', programArgs);\n      }\n\n      if (allowNonRestoredState) {\n        params = params.append('allowNonRestoredState', allowNonRestoredState);\n      }\n\n      return this.httpClient.post(`${BASE_URL}/jars/${jarId}/run`, requestParam, {\n        params\n      });\n    }\n    /**\n     * Get plan json from jar\n     * @param jarId\n     * @param entryClass\n     * @param parallelism\n     * @param programArgs\n     */\n\n\n    getPlan(jarId, entryClass, parallelism, programArgs) {\n      let params = new HttpParams();\n\n      if (entryClass) {\n        params = params.append('entry-class', entryClass);\n      }\n\n      if (parallelism) {\n        params = params.append('parallelism', parallelism);\n      }\n\n      if (programArgs) {\n        params = params.append('program-args', programArgs);\n      }\n\n      return this.httpClient.get(`${BASE_URL}/jars/${jarId}/plan`, {\n        params\n      }).pipe(map(data => {\n        const links = [];\n        let nodes = [];\n\n        if (data.plan.nodes.length) {\n          nodes = data.plan.nodes.map(node => {\n            return Object.assign(Object.assign({}, node), {\n              detail: undefined\n            });\n          });\n          nodes.forEach(node => {\n            if (node.inputs && node.inputs.length) {\n              node.inputs.forEach(input => {\n                links.push(Object.assign(Object.assign({}, input), {\n                  source: input.id,\n                  target: node.id,\n                  id: `${input.id}-${node.id}`\n                }));\n              });\n            }\n          });\n        }\n\n        return {\n          nodes,\n          links\n        };\n      }));\n    }\n\n  }\n\n  JarService.ɵfac = function JarService_Factory(t) {\n    return new (t || JarService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  JarService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: JarService,\n    factory: JarService.ɵfac,\n    providedIn: 'root'\n  });\n  return JarService;\n})();","map":null,"metadata":{},"sourceType":"module"}