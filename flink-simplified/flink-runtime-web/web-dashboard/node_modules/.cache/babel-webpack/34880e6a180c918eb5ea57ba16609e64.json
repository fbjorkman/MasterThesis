{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { curveLinear, line } from 'd3';\nimport * as dagre from 'dagre';\nexport class NzGraph {\n  constructor() {\n    this.config = {\n      ranker: 'network-simplex',\n      align: 'DL',\n      marginx: 20,\n      marginy: 20,\n      edgesep: 150,\n      ranksep: 150\n    };\n    this.layoutNodes = [];\n    this.layoutLinks = [];\n  }\n  /**\n   * Create graph\n   * @param opt\n   */\n\n\n  createGraph(opt = {}) {\n    this.graph = new dagre.graphlib.Graph(opt);\n    this.graph.setGraph(Object.assign({\n      rankdir: 'LR'\n    }, this.config));\n    this.graph.setDefaultEdgeLabel(() => ({}));\n  }\n  /**\n   * Set nodes for graph\n   * @param nodes\n   */\n\n\n  setNodes(nodes) {\n    nodes.forEach(n => {\n      n.width = n.width || 48;\n      n.height = n.height || 48;\n      this.graph.setNode(n.id, n);\n    });\n  }\n  /**\n   * Set links for graph\n   * @param links\n   */\n\n\n  setEdge(links) {\n    links.forEach(l => {\n      let length = 0;\n\n      if (l.local_strategy) {\n        length += l.local_strategy.length;\n      }\n\n      if (l.ship_strategy) {\n        length += l.ship_strategy.length;\n      }\n\n      l.width = (length || 1) * 3;\n      this.graph.setEdge(l.source, l.target, l);\n    });\n  }\n  /**\n   * Init graph layout\n   */\n\n\n  initLayout() {\n    if (!this.graph) {\n      return Promise.reject();\n    }\n\n    this.layoutNodes = [];\n    this.copyLayoutNodes = [];\n    this.layoutLinks = [];\n    this.copyLayoutLinks = [];\n    dagre.layout(this.graph);\n    const generatedGraph = this.graph.graph();\n\n    if (generatedGraph.width < generatedGraph.height) {\n      this.graph.setGraph(Object.assign({\n        rankdir: 'TB'\n      }, this.config));\n      this.graph.edges().forEach(e => {\n        const edge = this.graph.edge(e);\n        edge.height = edge.width;\n        edge.width = null;\n      });\n      dagre.layout(this.graph);\n    }\n\n    this.graph.nodes().forEach(id => {\n      const node = this.graph.node(id);\n      const transform = `translate(${node.x - node.width / 2 || 0}, ${node.y - 1 / 2 || 0})`;\n      node.options = {\n        transform,\n        oldTransform: transform,\n        scale: 1,\n        oldScale: 1,\n        focused: false\n      };\n      this.layoutNodes.push(Object.assign(Object.assign({}, node), {\n        options: Object.assign({}, node.options)\n      }));\n      this.copyLayoutNodes.push(Object.assign(Object.assign({}, node), {\n        options: Object.assign({}, node.options)\n      }));\n    });\n    this.graph.edges().forEach(e => {\n      const edge = this.graph.edge(e);\n      const initLine = this.generateLine(edge.points);\n      const link = {\n        id: edge.id,\n        source: edge.source,\n        target: edge.target,\n        points: [...edge.points],\n        options: {\n          line: initLine,\n          oldLine: initLine,\n          width: 1,\n          oldWidth: 1,\n          focused: false,\n          dominantBaseline: this.getDominantBaseline(edge)\n        },\n        detail: Object.assign({}, edge)\n      };\n      this.layoutLinks.push(Object.assign(Object.assign({}, link), {\n        options: Object.assign({}, link.options)\n      }));\n      this.copyLayoutLinks.push(Object.assign(Object.assign({}, link), {\n        options: Object.assign({}, link.options)\n      }));\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Calculate text base line\n   * @param edge\n   */\n\n\n  getDominantBaseline(edge) {\n    const firstPoint = edge.points[0];\n    const lastPoint = edge.points[edge.points.length - 1];\n    return lastPoint.x < firstPoint.x ? 'rtl' : 'ltr';\n  }\n  /**\n   * Zoom when focus on some node\n   * @param opt\n   */\n\n\n  zoomFocusLayout(opt) {\n    if (!this.graph.hasNode(opt.nodeId)) {\n      console.warn(`node ${opt.nodeId} not exist`);\n      return Promise.reject();\n    }\n\n    this.layoutNodes.forEach(node => {\n      const oNode = this.copyLayoutNodes.find(n => n.id === node.id);\n\n      if (oNode) {\n        node.options.oldScale = node.options.scale;\n        node.options.scale = oNode.options.scale;\n        node.options.focused = false;\n      }\n    });\n    const focusNode = this.layoutNodes.find(n => n.id === opt.nodeId);\n\n    if (focusNode) {\n      const circularNodes = this.circleNodes(focusNode);\n      focusNode.options.oldScale = focusNode.options.scale;\n      focusNode.options.scale = focusNode.options.oldScale * 1.2;\n      focusNode.options.focused = true;\n      const x = focusNode.x + 45;\n      const y = focusNode.y;\n      const focusedLinkIds = [];\n      this.layoutLinks.forEach(link => {\n        link.options.focused = link.source === opt.nodeId || link.target === opt.nodeId;\n\n        if (link.options.focused) {\n          focusedLinkIds.push(link.id);\n        }\n      });\n      return Promise.resolve({\n        focusedLinkIds,\n        circularNodeIds: circularNodes.map(n => n.id),\n        transform: {\n          x: opt.transform.x + opt.x - x,\n          y: opt.transform.y + opt.y - y,\n          k: 1\n        }\n      });\n    } else {\n      return Promise.reject();\n    }\n  }\n  /**\n   * Recover layout position\n   */\n\n\n  recoveryLayout() {\n    this.layoutNodes.forEach(node => {\n      const oNode = this.copyLayoutNodes.find(n => n.id === node.id);\n\n      if (oNode) {\n        node.options.oldTransform = node.options.transform;\n        node.options.transform = oNode.options.transform;\n        node.options.oldScale = node.options.scale;\n        node.options.scale = oNode.options.scale;\n        node.x = oNode.x;\n        node.y = oNode.y;\n        node.options.focused = false;\n      }\n    });\n    this.layoutLinks.forEach(link => {\n      link.options.focused = false;\n      const oldLink = this.copyLayoutLinks.find(ol => ol.id === link.id);\n\n      if (oldLink) {\n        link.points = [...oldLink.points];\n        link.options.oldLine = link.options.line;\n        link.options.line = oldLink.options.line;\n        link.options.oldWidth = link.options.width;\n        link.options.width = 1;\n      }\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Get circle node from selected node\n   * @param selectedNode\n   */\n\n\n  circleNodes(selectedNode) {\n    const nodes = [];\n\n    for (const link of this.layoutLinks) {\n      if (link.target === selectedNode.id) {\n        nodes.push(this.layoutNodes.find(n => n.id === link.source));\n      }\n\n      if (link.source === selectedNode.id) {\n        nodes.push(this.layoutNodes.find(n => n.id === link.target));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * Generate Line from points\n   * @param points\n   */\n\n\n  generateLine(points) {\n    const transformPoints = points;\n    const lineFunction = line().x(d => d.x).y(d => d.y).curve(curveLinear);\n    return lineFunction(transformPoints);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}